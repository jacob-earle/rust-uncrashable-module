/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const KERN_INFO: &'static [u8; 3usize] = b"\x016\0";
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EFAULT: u32 = 14;
pub const EINVAL: u32 = 22;
pub const ESPIPE: u32 = 29;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const FS_REQUIRES_DEV: u32 = 1;
pub const FS_BINARY_MOUNTDATA: u32 = 2;
pub const FS_HAS_SUBTYPE: u32 = 4;
pub const FS_USERNS_MOUNT: u32 = 8;
pub const FS_RENAME_DOES_D_MOVE: u32 = 32768;
pub const VERIFY_WRITE: u32 = 1;
pub const LINUX_VERSION_CODE: u32 = 267133;
pub type __s8 = c_types::c_schar;
pub type __u8 = c_types::c_uchar;
pub type __s16 = c_types::c_short;
pub type __u16 = c_types::c_ushort;
pub type __s32 = c_types::c_int;
pub type __u32 = c_types::c_uint;
pub type __s64 = c_types::c_longlong;
pub type __u64 = c_types::c_ulonglong;
pub type s8 = __s8;
pub type u8 = __u8;
pub type s16 = __s16;
pub type u16 = __u16;
pub type s32 = __s32;
pub type u32 = __u32;
pub type s64 = __s64;
pub type u64 = __u64;
pub type __kernel_long_t = c_types::c_long;
pub type __kernel_ulong_t = c_types::c_ulong;
pub type __kernel_mode_t = c_types::c_uint;
pub type __kernel_pid_t = c_types::c_int;
pub type __kernel_uid32_t = c_types::c_uint;
pub type __kernel_gid32_t = c_types::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_loff_t = c_types::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = c_types::c_int;
pub type __kernel_clockid_t = c_types::c_int;
pub type __poll_t = c_types::c_uint;
pub type __kernel_dev_t = u32;
pub type dev_t = __kernel_dev_t;
pub type mode_t = __kernel_mode_t;
pub type umode_t = c_types::c_ushort;
pub type pid_t = __kernel_pid_t;
pub type clockid_t = __kernel_clockid_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type loff_t = __kernel_loff_t;
pub type sector_t = c_types::c_ulong;
pub type blkcnt_t = c_types::c_ulong;
pub type gfp_t = c_types::c_uint;
pub type fmode_t = c_types::c_uint;
pub type phys_addr_t = u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct atomic_t {
    pub counter: c_types::c_int,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    assert_eq!(
        ::core::mem::size_of::<atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(atomic_t))
    );
    assert_eq!(
        ::core::mem::align_of::<atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(atomic_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<atomic_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct atomic64_t {
    pub counter: c_types::c_long,
}
#[test]
fn bindgen_test_layout_atomic64_t() {
    assert_eq!(
        ::core::mem::size_of::<atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(atomic64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<atomic64_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic64_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(
        ::core::mem::size_of::<list_head>(),
        16usize,
        concat!("Size of: ", stringify!(list_head))
    );
    assert_eq!(
        ::core::mem::align_of::<list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(list_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for list_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_head() {
    assert_eq!(
        ::core::mem::size_of::<hlist_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_head))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_head),
            "::",
            stringify!(first)
        )
    );
}
impl Default for hlist_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_node() {
    assert_eq!(
        ::core::mem::size_of::<hlist_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(pprev)
        )
    );
}
impl Default for hlist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct callback_head - callback structure for use with RCU and task_work"]
#[doc = " @next: next update requests in a list"]
#[doc = " @func: actual update function to call after the grace period."]
#[doc = ""]
#[doc = " The struct is aligned to size of pointer. On most architectures it happens"]
#[doc = " naturally due ABI requirements, but some architectures (like CRIS) have"]
#[doc = " weird ABI and we need to ask it explicitly."]
#[doc = ""]
#[doc = " The alignment is required to guarantee that bit 0 of @next will be"]
#[doc = " clear under normal conditions -- as long as we use call_rcu(),"]
#[doc = " call_rcu_bh(), call_rcu_sched(), or call_srcu() to queue callback."]
#[doc = ""]
#[doc = " This guarantee is important for few reasons:"]
#[doc = "  - future call_rcu_lazy() will make use of lower bits in the pointer;"]
#[doc = "  - the structure shares storage space in struct page with @compound_head,"]
#[doc = "    which encode PageTail() in bit 0. The guarantee is needed to avoid"]
#[doc = "    false-positive PageTail()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
#[test]
fn bindgen_test_layout_callback_head() {
    assert_eq!(
        ::core::mem::size_of::<callback_head>(),
        16usize,
        concat!("Size of: ", stringify!(callback_head))
    );
    assert_eq!(
        ::core::mem::align_of::<callback_head>(),
        8usize,
        concat!("Alignment of ", stringify!(callback_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callback_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callback_head>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(func)
        )
    );
}
impl Default for callback_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct module {
    pub state: module_state,
    pub list: list_head,
    pub name: [c_types::c_char; 56usize],
    pub mkobj: module_kobject,
    pub modinfo_attrs: *mut module_attribute,
    pub version: *const c_types::c_char,
    pub srcversion: *const c_types::c_char,
    pub holders_dir: *mut kobject,
    pub syms: *const kernel_symbol,
    pub crcs: *const s32,
    pub num_syms: c_types::c_uint,
    pub param_lock: mutex,
    pub kp: *mut kernel_param,
    pub num_kp: c_types::c_uint,
    pub num_gpl_syms: c_types::c_uint,
    pub gpl_syms: *const kernel_symbol,
    pub gpl_crcs: *const s32,
    pub unused_syms: *const kernel_symbol,
    pub unused_crcs: *const s32,
    pub num_unused_syms: c_types::c_uint,
    pub num_unused_gpl_syms: c_types::c_uint,
    pub unused_gpl_syms: *const kernel_symbol,
    pub unused_gpl_crcs: *const s32,
    pub sig_ok: bool_,
    pub async_probe_requested: bool_,
    pub gpl_future_syms: *const kernel_symbol,
    pub gpl_future_crcs: *const s32,
    pub num_gpl_future_syms: c_types::c_uint,
    pub num_exentries: c_types::c_uint,
    pub extable: *mut exception_table_entry,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> c_types::c_int>,
    pub core_layout: module_layout,
    pub init_layout: module_layout,
    pub arch: mod_arch_specific,
    pub taints: c_types::c_ulong,
    pub num_bugs: c_types::c_uint,
    pub bug_list: list_head,
    pub bug_table: *mut bug_entry,
    pub kallsyms: *mut mod_kallsyms,
    pub core_kallsyms: mod_kallsyms,
    pub sect_attrs: *mut module_sect_attrs,
    pub notes_attrs: *mut module_notes_attrs,
    pub args: *mut c_types::c_char,
    pub percpu: *mut c_types::c_void,
    pub percpu_size: c_types::c_uint,
    pub num_tracepoints: c_types::c_uint,
    pub tracepoints_ptrs: *mut tracepoint_ptr_t,
    pub jump_entries: *mut jump_entry,
    pub num_jump_entries: c_types::c_uint,
    pub num_trace_bprintk_fmt: c_types::c_uint,
    pub trace_bprintk_fmt_start: *mut *const c_types::c_char,
    pub trace_events: *mut *mut trace_event_call,
    pub num_trace_events: c_types::c_uint,
    pub trace_evals: *mut *mut trace_eval_map,
    pub num_trace_evals: c_types::c_uint,
    pub num_ftrace_callsites: c_types::c_uint,
    pub ftrace_callsites: *mut c_types::c_ulong,
    pub klp: bool_,
    pub klp_alive: bool_,
    pub klp_info: *mut klp_modinfo,
    pub source_list: list_head,
    pub target_list: list_head,
    pub exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub refcnt: atomic_t,
    pub ei_funcs: *mut error_injection_entry,
    pub num_ei_funcs: c_types::c_uint,
    pub __bindgen_padding_0: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_module() {
    assert_eq!(
        ::core::mem::size_of::<module>(),
        832usize,
        concat!("Size of: ", stringify!(module))
    );
    assert_eq!(
        ::core::mem::align_of::<module>(),
        64usize,
        concat!("Alignment of ", stringify!(module))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).mkobj as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(mkobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).modinfo_attrs as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(modinfo_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).version as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).srcversion as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(srcversion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).holders_dir as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(holders_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).syms as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).crcs as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_syms as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).param_lock as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(param_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).kp as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_kp as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_gpl_syms as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_syms as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_crcs as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_syms as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_crcs as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_unused_syms as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_unused_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_unused_gpl_syms as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_unused_gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_gpl_syms as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_gpl_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).unused_gpl_crcs as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(unused_gpl_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).sig_ok as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(sig_ok)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).async_probe_requested as *const _ as usize },
        337usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(async_probe_requested)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_future_syms as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_future_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).gpl_future_crcs as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(gpl_future_crcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_gpl_future_syms as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_gpl_future_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_exentries as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_exentries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).extable as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(extable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).init as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).core_layout as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(core_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).init_layout as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(init_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).arch as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).taints as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(taints)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_bugs as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_bugs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).bug_list as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(bug_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).bug_table as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(bug_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).kallsyms as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(kallsyms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).core_kallsyms as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(core_kallsyms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).sect_attrs as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(sect_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).notes_attrs as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(notes_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).args as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).percpu as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(percpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).percpu_size as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(percpu_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_tracepoints as *const _ as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_tracepoints)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).tracepoints_ptrs as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(tracepoints_ptrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).jump_entries as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(jump_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_jump_entries as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_jump_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_trace_bprintk_fmt as *const _ as usize },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_trace_bprintk_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).trace_bprintk_fmt_start as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(trace_bprintk_fmt_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).trace_events as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(trace_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_trace_events as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_trace_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).trace_evals as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(trace_evals)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_trace_evals as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_trace_evals)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_ftrace_callsites as *const _ as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_ftrace_callsites)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).ftrace_callsites as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(ftrace_callsites)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).klp as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(klp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).klp_alive as *const _ as usize },
        729usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(klp_alive)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).klp_info as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(klp_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).source_list as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(source_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).target_list as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(target_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).exit as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(exit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).refcnt as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).ei_funcs as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(ei_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module>())).num_ei_funcs as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(module),
            "::",
            stringify!(num_ei_funcs)
        )
    );
}
impl Default for module {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut __this_module: module;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernel_symbol {
    pub value_offset: c_types::c_int,
    pub name_offset: c_types::c_int,
}
#[test]
fn bindgen_test_layout_kernel_symbol() {
    assert_eq!(
        ::core::mem::size_of::<kernel_symbol>(),
        8usize,
        concat!("Size of: ", stringify!(kernel_symbol))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_symbol>(),
        4usize,
        concat!("Alignment of ", stringify!(kernel_symbol))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_symbol>())).value_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(value_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_symbol>())).name_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(name_offset)
        )
    );
}
pub type jump_label_t = u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct jump_entry {
    pub code: jump_label_t,
    pub target: jump_label_t,
    pub key: jump_label_t,
}
#[test]
fn bindgen_test_layout_jump_entry() {
    assert_eq!(
        ::core::mem::size_of::<jump_entry>(),
        24usize,
        concat!("Size of: ", stringify!(jump_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<jump_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(jump_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<jump_entry>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<jump_entry>())).target as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<jump_entry>())).key as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_operations {
    pub owner: *mut module,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: c_types::c_int) -> loff_t,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut c_types::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const c_types::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub write_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub iterate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> c_types::c_int,
    >,
    pub iterate_shared: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> c_types::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub unlocked_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_uint,
            arg3: c_types::c_ulong,
        ) -> c_types::c_long,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_uint,
            arg3: c_types::c_ulong,
        ) -> c_types::c_long,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> c_types::c_int,
    >,
    pub mmap_supported_flags: c_types::c_ulong,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> c_types::c_int,
    >,
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, id: fl_owner_t) -> c_types::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> c_types::c_int,
    >,
    pub fsync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            datasync: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub fasync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: c_types::c_int,
            arg2: *mut file,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_int,
            arg3: *mut file_lock,
        ) -> c_types::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut page,
            arg3: c_types::c_int,
            arg4: usize,
            arg5: *mut loff_t,
            arg6: c_types::c_int,
        ) -> isize,
    >,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_ulong,
            arg3: c_types::c_ulong,
            arg4: c_types::c_ulong,
            arg5: c_types::c_ulong,
        ) -> c_types::c_ulong,
    >,
    pub check_flags:
        ::core::option::Option<unsafe extern "C" fn(arg1: c_types::c_int) -> c_types::c_int>,
    pub flock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_int,
            arg3: *mut file_lock,
        ) -> c_types::c_int,
    >,
    pub splice_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: usize,
            arg5: c_types::c_uint,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: usize,
            arg5: c_types::c_uint,
        ) -> isize,
    >,
    pub setlease: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: c_types::c_long,
            arg3: *mut *mut file_lock,
            arg4: *mut *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub fallocate: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            mode: c_types::c_int,
            offset: loff_t,
            len: loff_t,
        ) -> c_types::c_long,
    >,
    pub show_fdinfo: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, f: *mut file)>,
    pub copy_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: usize,
            arg6: c_types::c_uint,
        ) -> isize,
    >,
    pub clone_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: u64,
        ) -> c_types::c_int,
    >,
    pub dedupe_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: u64,
        ) -> c_types::c_int,
    >,
    pub fadvise: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: c_types::c_int,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_file_operations() {
    assert_eq!(
        ::core::mem::size_of::<file_operations>(),
        256usize,
        concat!("Size of: ", stringify!(file_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<file_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(file_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).llseek as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(llseek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).read as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).write as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).read_iter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(read_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).write_iter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(write_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).iterate as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(iterate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).iterate_shared as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(iterate_shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).poll as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).unlocked_ioctl as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(unlocked_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).compat_ioctl as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(compat_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).mmap as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).mmap_supported_flags as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(mmap_supported_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).open as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).flush as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).release as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).fsync as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fsync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).fasync as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fasync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).lock as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).sendpage as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(sendpage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).get_unmapped_area as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(get_unmapped_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).check_flags as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(check_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).flock as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(flock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).splice_write as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(splice_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).splice_read as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(splice_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).setlease as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(setlease)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).fallocate as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fallocate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).show_fdinfo as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(show_fdinfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).copy_file_range as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(copy_file_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).clone_file_range as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(clone_file_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_operations>())).dedupe_file_range as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(dedupe_file_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_operations>())).fadvise as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fadvise)
        )
    );
}
impl Default for file_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8,
    pub pending: u8,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).locked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).pending as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pending)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16,
    pub tail: u16,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).locked_pending
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(locked_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).tail as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qspinlock__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
impl Default for qspinlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_qspinlock() {
    assert_eq!(
        ::core::mem::size_of::<qspinlock>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<qspinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock))
    );
}
impl Default for qspinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8,
    pub __lstate: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).wlocked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(wlocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).__lstate as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__lstate)
        )
    );
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qrwlock__bindgen_ty_1>())).cnts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1),
            "::",
            stringify!(cnts)
        )
    );
}
impl Default for qrwlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_qrwlock() {
    assert_eq!(
        ::core::mem::size_of::<qrwlock>(),
        8usize,
        concat!("Size of: ", stringify!(qrwlock))
    );
    assert_eq!(
        ::core::mem::align_of::<qrwlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qrwlock>())).wait_lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock),
            "::",
            stringify!(wait_lock)
        )
    );
}
impl Default for qrwlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type arch_rwlock_t = qrwlock;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lock_class_key {}
#[test]
fn bindgen_test_layout_lock_class_key() {
    assert_eq!(
        ::core::mem::size_of::<lock_class_key>(),
        0usize,
        concat!("Size of: ", stringify!(lock_class_key))
    );
    assert_eq!(
        ::core::mem::align_of::<lock_class_key>(),
        1usize,
        concat!("Alignment of ", stringify!(lock_class_key))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
#[test]
fn bindgen_test_layout_raw_spinlock() {
    assert_eq!(
        ::core::mem::size_of::<raw_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(raw_spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<raw_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(raw_spinlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<raw_spinlock>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_spinlock),
            "::",
            stringify!(raw_lock)
        )
    );
}
impl Default for raw_spinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_spinlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<spinlock__bindgen_ty_1>())).rlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spinlock__bindgen_ty_1),
            "::",
            stringify!(rlock)
        )
    );
}
impl Default for spinlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_spinlock() {
    assert_eq!(
        ::core::mem::size_of::<spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock))
    );
}
impl Default for spinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
#[test]
fn bindgen_test_layout_rwlock_t() {
    assert_eq!(
        ::core::mem::size_of::<rwlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rwlock_t>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rwlock_t),
            "::",
            stringify!(raw_lock)
        )
    );
}
impl Default for rwlock_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type atomic_long_t = atomic64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pt_regs {
    pub r15: c_types::c_ulong,
    pub r14: c_types::c_ulong,
    pub r13: c_types::c_ulong,
    pub r12: c_types::c_ulong,
    pub bp: c_types::c_ulong,
    pub bx: c_types::c_ulong,
    pub r11: c_types::c_ulong,
    pub r10: c_types::c_ulong,
    pub r9: c_types::c_ulong,
    pub r8: c_types::c_ulong,
    pub ax: c_types::c_ulong,
    pub cx: c_types::c_ulong,
    pub dx: c_types::c_ulong,
    pub si: c_types::c_ulong,
    pub di: c_types::c_ulong,
    pub orig_ax: c_types::c_ulong,
    pub ip: c_types::c_ulong,
    pub cs: c_types::c_ulong,
    pub flags: c_types::c_ulong,
    pub sp: c_types::c_ulong,
    pub ss: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_pt_regs() {
    assert_eq!(
        ::core::mem::size_of::<pt_regs>(),
        168usize,
        concat!("Size of: ", stringify!(pt_regs))
    );
    assert_eq!(
        ::core::mem::align_of::<pt_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_regs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).bp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).bx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r11 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r10 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r9 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).r8 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).ax as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).cx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).dx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).si as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).di as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).orig_ax as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(orig_ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).ip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).cs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).flags as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).sp as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pt_regs>())).ss as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ss)
        )
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Default, Copy, Clone)]
pub struct desc_struct {
    pub _bindgen_opaque_blob: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_desc_struct() {
    assert_eq!(
        ::core::mem::size_of::<desc_struct>(),
        8usize,
        concat!("Size of: ", stringify!(desc_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<desc_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(desc_struct))
    );
}
pub type pgdval_t = c_types::c_ulong;
pub type pgprotval_t = c_types::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
#[test]
fn bindgen_test_layout_pgprot() {
    assert_eq!(
        ::core::mem::size_of::<pgprot>(),
        8usize,
        concat!("Size of: ", stringify!(pgprot))
    );
    assert_eq!(
        ::core::mem::align_of::<pgprot>(),
        8usize,
        concat!("Alignment of ", stringify!(pgprot))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pgprot>())).pgprot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgprot),
            "::",
            stringify!(pgprot)
        )
    );
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[test]
fn bindgen_test_layout_pgd_t() {
    assert_eq!(
        ::core::mem::size_of::<pgd_t>(),
        8usize,
        concat!("Size of: ", stringify!(pgd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pgd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pgd_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pgd_t>())).pgd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgd_t),
            "::",
            stringify!(pgd)
        )
    );
}
pub type pgtable_t = *mut page;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seq_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct math_emu_info {
    pub ___orig_eip: c_types::c_long,
    pub regs: *mut pt_regs,
}
#[test]
fn bindgen_test_layout_math_emu_info() {
    assert_eq!(
        ::core::mem::size_of::<math_emu_info>(),
        16usize,
        concat!("Size of: ", stringify!(math_emu_info))
    );
    assert_eq!(
        ::core::mem::align_of::<math_emu_info>(),
        8usize,
        concat!("Alignment of ", stringify!(math_emu_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<math_emu_info>())).___orig_eip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(___orig_eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<math_emu_info>())).regs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(regs)
        )
    );
}
impl Default for math_emu_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: c_types::c_int,
    pub file_disp: c_types::c_int,
    pub line: c_types::c_ushort,
    pub flags: c_types::c_ushort,
}
#[test]
fn bindgen_test_layout_bug_entry() {
    assert_eq!(
        ::core::mem::size_of::<bug_entry>(),
        12usize,
        concat!("Size of: ", stringify!(bug_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<bug_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(bug_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).bug_addr_disp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(bug_addr_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).file_disp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(file_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bug_entry>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpumask {
    pub bits: [c_types::c_ulong; 128usize],
}
#[test]
fn bindgen_test_layout_cpumask() {
    assert_eq!(
        ::core::mem::size_of::<cpumask>(),
        1024usize,
        concat!("Size of: ", stringify!(cpumask))
    );
    assert_eq!(
        ::core::mem::align_of::<cpumask>(),
        8usize,
        concat!("Alignment of ", stringify!(cpumask))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpumask>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpumask),
            "::",
            stringify!(bits)
        )
    );
}
impl Default for cpumask {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cpumask_t = cpumask;
pub type tracepoint_ptr_t = c_types::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fregs_state {
    pub cwd: u32,
    pub swd: u32,
    pub twd: u32,
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
    pub st_space: [u32; 20usize],
    pub status: u32,
}
#[test]
fn bindgen_test_layout_fregs_state() {
    assert_eq!(
        ::core::mem::size_of::<fregs_state>(),
        112usize,
        concat!("Size of: ", stringify!(fregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<fregs_state>(),
        4usize,
        concat!("Alignment of ", stringify!(fregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fregs_state>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct fxregs_state {
    pub cwd: u16,
    pub swd: u16,
    pub twd: u16,
    pub fop: u16,
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1,
    pub mxcsr: u32,
    pub mxcsr_mask: u32,
    pub st_space: [u32; 32usize],
    pub xmm_space: [u32; 64usize],
    pub padding: [u32; 12usize],
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_1 {
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    pub rip: u64,
    pub rdp: u64,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rdp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fcs as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).foo as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fos as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fos)
        )
    );
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_1))
    );
}
impl Default for fxregs_state__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_2 {
    pub padding1: [u32; 12usize],
    pub sw_reserved: [u32; 12usize],
    _bindgen_union_align: [u32; 12usize],
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_2>())).padding1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fxregs_state__bindgen_ty_2>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(sw_reserved)
        )
    );
}
impl Default for fxregs_state__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_fxregs_state() {
    assert_eq!(
        ::core::mem::size_of::<fxregs_state>(),
        512usize,
        concat!("Size of: ", stringify!(fxregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<fxregs_state>(),
        16usize,
        concat!("Alignment of ", stringify!(fxregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).twd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).mxcsr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).st_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).xmm_space as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(xmm_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fxregs_state>())).padding as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(padding)
        )
    );
}
impl Default for fxregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swregs_state {
    pub cwd: u32,
    pub swd: u32,
    pub twd: u32,
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
    pub st_space: [u32; 20usize],
    pub ftop: u8,
    pub changed: u8,
    pub lookahead: u8,
    pub no_update: u8,
    pub rm: u8,
    pub alimit: u8,
    pub info: *mut math_emu_info,
    pub entry_eip: u32,
}
#[test]
fn bindgen_test_layout_swregs_state() {
    assert_eq!(
        ::core::mem::size_of::<swregs_state>(),
        136usize,
        concat!("Size of: ", stringify!(swregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<swregs_state>(),
        8usize,
        concat!("Alignment of ", stringify!(swregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).ftop as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(ftop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).changed as *const _ as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).lookahead as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(lookahead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).no_update as *const _ as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(no_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).rm as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(rm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).alimit as *const _ as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(alimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).info as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<swregs_state>())).entry_eip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(entry_eip)
        )
    );
}
impl Default for swregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct xregs_state {
    pub _bindgen_opaque_blob: [u8; 576usize],
}
#[test]
fn bindgen_test_layout_xregs_state() {
    assert_eq!(
        ::core::mem::size_of::<xregs_state>(),
        576usize,
        concat!("Size of: ", stringify!(xregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<xregs_state>(),
        64usize,
        concat!("Alignment of ", stringify!(xregs_state))
    );
}
impl Default for xregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct fpregs_state {
    pub fsave: __BindgenUnionField<fregs_state>,
    pub fxsave: __BindgenUnionField<fxregs_state>,
    pub soft: __BindgenUnionField<swregs_state>,
    pub xsave: __BindgenUnionField<xregs_state>,
    pub __padding: __BindgenUnionField<[u8; 4096usize]>,
    pub bindgen_union_field: [u8; 4096usize],
}
#[test]
fn bindgen_test_layout_fpregs_state() {
    assert_eq!(
        ::core::mem::size_of::<fpregs_state>(),
        4096usize,
        concat!("Size of: ", stringify!(fpregs_state))
    );
    assert_eq!(
        ::core::mem::align_of::<fpregs_state>(),
        64usize,
        concat!("Alignment of ", stringify!(fpregs_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).fsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).fxsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fxsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).soft as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(soft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).xsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(xsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpregs_state>())).__padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(__padding)
        )
    );
}
impl Default for fpregs_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct fpu {
    pub last_cpu: c_types::c_uint,
    pub initialized: c_types::c_uchar,
    pub __bindgen_padding_0: [u64; 7usize],
    pub state: fpregs_state,
}
#[test]
fn bindgen_test_layout_fpu() {
    assert_eq!(
        ::core::mem::size_of::<fpu>(),
        4160usize,
        concat!("Size of: ", stringify!(fpu))
    );
    assert_eq!(
        ::core::mem::align_of::<fpu>(),
        64usize,
        concat!("Alignment of ", stringify!(fpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpu>())).last_cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(last_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpu>())).initialized as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fpu>())).state as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(state)
        )
    );
}
impl Default for fpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mm_segment_t {
    pub seg: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_mm_segment_t() {
    assert_eq!(
        ::core::mem::size_of::<mm_segment_t>(),
        8usize,
        concat!("Size of: ", stringify!(mm_segment_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_segment_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_segment_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_segment_t>())).seg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_segment_t),
            "::",
            stringify!(seg)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
pub struct thread_struct {
    pub tls_array: [desc_struct; 3usize],
    pub sp: c_types::c_ulong,
    pub es: c_types::c_ushort,
    pub ds: c_types::c_ushort,
    pub fsindex: c_types::c_ushort,
    pub gsindex: c_types::c_ushort,
    pub fsbase: c_types::c_ulong,
    pub gsbase: c_types::c_ulong,
    pub ptrace_bps: [*mut perf_event; 4usize],
    pub debugreg6: c_types::c_ulong,
    pub ptrace_dr7: c_types::c_ulong,
    pub cr2: c_types::c_ulong,
    pub trap_nr: c_types::c_ulong,
    pub error_code: c_types::c_ulong,
    pub io_bitmap_ptr: *mut c_types::c_ulong,
    pub iopl: c_types::c_ulong,
    pub io_bitmap_max: c_types::c_uint,
    pub addr_limit: mm_segment_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u64; 3usize],
    pub fpu: fpu,
}
#[test]
fn bindgen_test_layout_thread_struct() {
    assert_eq!(
        ::core::mem::size_of::<thread_struct>(),
        4352usize,
        concat!("Size of: ", stringify!(thread_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<thread_struct>(),
        64usize,
        concat!("Alignment of ", stringify!(thread_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).tls_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(tls_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).sp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).es as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).ds as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).fsindex as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).gsindex as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).fsbase as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).gsbase as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).ptrace_bps as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).debugreg6 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(debugreg6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).ptrace_dr7 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_dr7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).cr2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).trap_nr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(trap_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).error_code as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).io_bitmap_ptr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(io_bitmap_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).iopl as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(iopl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).io_bitmap_max as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(io_bitmap_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).addr_limit as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(addr_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_struct>())).fpu as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fpu)
        )
    );
}
impl Default for thread_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl thread_struct {
    #[inline]
    pub fn sig_on_uaccess_err(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_on_uaccess_err(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uaccess_err(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uaccess_err(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sig_on_uaccess_err: c_types::c_uint,
        uaccess_err: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sig_on_uaccess_err: u32 = unsafe { ::core::mem::transmute(sig_on_uaccess_err) };
            sig_on_uaccess_err as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let uaccess_err: u32 = unsafe { ::core::mem::transmute(uaccess_err) };
            uaccess_err as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
#[test]
fn bindgen_test_layout_optimistic_spin_queue() {
    assert_eq!(
        ::core::mem::size_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Size of: ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Alignment of ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<optimistic_spin_queue>())).tail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_queue),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
#[test]
fn bindgen_test_layout_mutex() {
    assert_eq!(
        ::core::mem::size_of::<mutex>(),
        32usize,
        concat!("Size of: ", stringify!(mutex))
    );
    assert_eq!(
        ::core::mem::align_of::<mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(mutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).wait_lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).osq as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(osq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mutex>())).wait_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_list)
        )
    );
}
impl Default for mutex {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type time64_t = __s64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __kernel_time_t,
    pub tv_nsec: c_types::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: time64_t,
    pub tv_nsec: c_types::c_long,
}
#[test]
fn bindgen_test_layout_timespec64() {
    assert_eq!(
        ::core::mem::size_of::<timespec64>(),
        16usize,
        concat!("Size of: ", stringify!(timespec64))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec64>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec64>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec64>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec64),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compat_timespec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    _unused: [u8; 0],
}
pub const timespec_type_TT_NONE: timespec_type = 0;
pub const timespec_type_TT_NATIVE: timespec_type = 1;
pub const timespec_type_TT_COMPAT: timespec_type = 2;
pub type timespec_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub fn_:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut restart_block) -> c_types::c_long>,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32,
    pub val: u32,
    pub flags: u32,
    pub bitset: u32,
    pub time: u64,
    pub uaddr2: *mut u32,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).val as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).flags as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).bitset
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bitset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).time as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr2
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr2)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut timespec,
    pub compat_rmtp: *mut compat_timespec,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .rmtp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rmtp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .compat_rmtp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(compat_rmtp)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).clockid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).type_ as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).expires
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(expires)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: c_types::c_int,
    pub has_timeout: c_types::c_int,
    pub tv_sec: c_types::c_ulong,
    pub tv_nsec: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).ufds as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ufds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).nfds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(nfds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).has_timeout
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(has_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_sec
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_nsec
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_nsec)
        )
    );
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<restart_block__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).futex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).nanosleep as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(nanosleep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).poll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(poll)
        )
    );
}
impl Default for restart_block__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_restart_block() {
    assert_eq!(
        ::core::mem::size_of::<restart_block>(),
        48usize,
        concat!("Size of: ", stringify!(restart_block))
    );
    assert_eq!(
        ::core::mem::align_of::<restart_block>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<restart_block>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block),
            "::",
            stringify!(fn_)
        )
    );
}
impl Default for restart_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct thread_info {
    pub flags: c_types::c_ulong,
    pub status: u32,
}
#[test]
fn bindgen_test_layout_thread_info() {
    assert_eq!(
        ::core::mem::size_of::<thread_info>(),
        16usize,
        concat!("Size of: ", stringify!(thread_info))
    );
    assert_eq!(
        ::core::mem::align_of::<thread_info>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<thread_info>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_tree_node {
    pub shift: c_types::c_uchar,
    pub offset: c_types::c_uchar,
    pub count: c_types::c_uchar,
    pub exceptional: c_types::c_uchar,
    pub parent: *mut radix_tree_node,
    pub root: *mut radix_tree_root,
    pub __bindgen_anon_1: radix_tree_node__bindgen_ty_1,
    pub slots: [*mut c_types::c_void; 64usize],
    pub tags: [[c_types::c_ulong; 1usize]; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union radix_tree_node__bindgen_ty_1 {
    pub private_list: list_head,
    pub callback_head: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_radix_tree_node__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<radix_tree_node__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(radix_tree_node__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<radix_tree_node__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(radix_tree_node__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<radix_tree_node__bindgen_ty_1>())).private_list as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node__bindgen_ty_1),
            "::",
            stringify!(private_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<radix_tree_node__bindgen_ty_1>())).callback_head as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node__bindgen_ty_1),
            "::",
            stringify!(callback_head)
        )
    );
}
impl Default for radix_tree_node__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_radix_tree_node() {
    assert_eq!(
        ::core::mem::size_of::<radix_tree_node>(),
        576usize,
        concat!("Size of: ", stringify!(radix_tree_node))
    );
    assert_eq!(
        ::core::mem::align_of::<radix_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(radix_tree_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).shift as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).offset as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).count as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).exceptional as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(exceptional)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).root as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).slots as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_node>())).tags as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_node),
            "::",
            stringify!(tags)
        )
    );
}
impl Default for radix_tree_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_tree_root {
    pub xa_lock: spinlock_t,
    pub gfp_mask: gfp_t,
    pub rnode: *mut radix_tree_node,
}
#[test]
fn bindgen_test_layout_radix_tree_root() {
    assert_eq!(
        ::core::mem::size_of::<radix_tree_root>(),
        16usize,
        concat!("Size of: ", stringify!(radix_tree_root))
    );
    assert_eq!(
        ::core::mem::align_of::<radix_tree_root>(),
        8usize,
        concat!("Alignment of ", stringify!(radix_tree_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_root>())).xa_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_root),
            "::",
            stringify!(xa_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_root>())).gfp_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_root),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<radix_tree_root>())).rnode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_root),
            "::",
            stringify!(rnode)
        )
    );
}
impl Default for radix_tree_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
#[test]
fn bindgen_test_layout_wait_queue_head() {
    assert_eq!(
        ::core::mem::size_of::<wait_queue_head>(),
        24usize,
        concat!("Size of: ", stringify!(wait_queue_head))
    );
    assert_eq!(
        ::core::mem::align_of::<wait_queue_head>(),
        8usize,
        concat!("Alignment of ", stringify!(wait_queue_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait_queue_head>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_head),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wait_queue_head>())).head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_head),
            "::",
            stringify!(head)
        )
    );
}
impl Default for wait_queue_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type wait_queue_head_t = wait_queue_head;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seqcount {
    pub sequence: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_seqcount() {
    assert_eq!(
        ::core::mem::size_of::<seqcount>(),
        4usize,
        concat!("Size of: ", stringify!(seqcount))
    );
    assert_eq!(
        ::core::mem::align_of::<seqcount>(),
        4usize,
        concat!("Alignment of ", stringify!(seqcount))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seqcount>())).sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqcount),
            "::",
            stringify!(sequence)
        )
    );
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nodemask_t {
    pub bits: [c_types::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout_nodemask_t() {
    assert_eq!(
        ::core::mem::size_of::<nodemask_t>(),
        128usize,
        concat!("Size of: ", stringify!(nodemask_t))
    );
    assert_eq!(
        ::core::mem::align_of::<nodemask_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nodemask_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nodemask_t>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nodemask_t),
            "::",
            stringify!(bits)
        )
    );
}
pub type isolate_mode_t = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub wait_list: list_head,
    pub wait_lock: raw_spinlock_t,
    pub osq: optimistic_spin_queue,
    pub owner: *mut task_struct,
}
#[test]
fn bindgen_test_layout_rw_semaphore() {
    assert_eq!(
        ::core::mem::size_of::<rw_semaphore>(),
        40usize,
        concat!("Size of: ", stringify!(rw_semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<rw_semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(rw_semaphore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).wait_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(wait_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).wait_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).osq as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(osq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rw_semaphore>())).owner as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(owner)
        )
    );
}
impl Default for rw_semaphore {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ktime_t = s64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workqueue_struct {
    _unused: [u8; 0],
}
pub type work_func_t = ::core::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
#[test]
fn bindgen_test_layout_work_struct() {
    assert_eq!(
        ::core::mem::size_of::<work_struct>(),
        32usize,
        concat!("Size of: ", stringify!(work_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<work_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(work_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<work_struct>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<work_struct>())).entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<work_struct>())).func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(func)
        )
    );
}
impl Default for work_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: c_types::c_uint,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_completion() {
    assert_eq!(
        ::core::mem::size_of::<completion>(),
        32usize,
        concat!("Size of: ", stringify!(completion))
    );
    assert_eq!(
        ::core::mem::align_of::<completion>(),
        8usize,
        concat!("Alignment of ", stringify!(completion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<completion>())).done as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(completion),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<completion>())).wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(completion),
            "::",
            stringify!(wait)
        )
    );
}
impl Default for completion {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub ctx_id: u64,
    pub tlb_gen: atomic64_t,
    pub ldt_usr_sem: rw_semaphore,
    pub ldt: *mut ldt_struct,
    pub ia32_compat: c_types::c_ushort,
    pub lock: mutex,
    pub vdso: *mut c_types::c_void,
    pub vdso_image: *const vdso_image,
    pub perf_rdpmc_allowed: atomic_t,
    pub pkey_allocation_map: u16,
    pub execute_only_pkey: s16,
    pub bd_addr: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_mm_context_t() {
    assert_eq!(
        ::core::mem::size_of::<mm_context_t>(),
        136usize,
        concat!("Size of: ", stringify!(mm_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_context_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ctx_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ctx_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).tlb_gen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(tlb_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ldt_usr_sem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ldt_usr_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ldt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ldt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).ia32_compat as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ia32_compat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).vdso as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(vdso)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).vdso_image as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(vdso_image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_context_t>())).perf_rdpmc_allowed as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(perf_rdpmc_allowed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_context_t>())).pkey_allocation_map as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(pkey_allocation_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).execute_only_pkey as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(execute_only_pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_context_t>())).bd_addr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(bd_addr)
        )
    );
}
impl Default for mm_context_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
#[test]
fn bindgen_test_layout_llist_node() {
    assert_eq!(
        ::core::mem::size_of::<llist_node>(),
        8usize,
        concat!("Size of: ", stringify!(llist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<llist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(llist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<llist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llist_node),
            "::",
            stringify!(next)
        )
    );
}
impl Default for llist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: c_types::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_node() {
    assert_eq!(
        ::core::mem::size_of::<rb_node>(),
        24usize,
        concat!("Size of: ", stringify!(rb_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rb_node>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).__rb_parent_color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(__rb_parent_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).rb_right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_node>())).rb_left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_left)
        )
    );
}
impl Default for rb_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root() {
    assert_eq!(
        ::core::mem::size_of::<rb_root>(),
        8usize,
        concat!("Size of: ", stringify!(rb_root))
    );
    assert_eq!(
        ::core::mem::align_of::<rb_root>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_root>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root),
            "::",
            stringify!(rb_node)
        )
    );
}
impl Default for rb_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root_cached() {
    assert_eq!(
        ::core::mem::size_of::<rb_root_cached>(),
        16usize,
        concat!("Size of: ", stringify!(rb_root_cached))
    );
    assert_eq!(
        ::core::mem::align_of::<rb_root_cached>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root_cached))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_root_cached>())).rb_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rb_root_cached>())).rb_leftmost as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_leftmost)
        )
    );
}
impl Default for rb_root_cached {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_struct {
    pub next: *mut vm_struct,
    pub addr: *mut c_types::c_void,
    pub size: c_types::c_ulong,
    pub flags: c_types::c_ulong,
    pub pages: *mut *mut page,
    pub nr_pages: c_types::c_uint,
    pub phys_addr: phys_addr_t,
    pub caller: *const c_types::c_void,
}
#[test]
fn bindgen_test_layout_vm_struct() {
    assert_eq!(
        ::core::mem::size_of::<vm_struct>(),
        64usize,
        concat!("Size of: ", stringify!(vm_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).pages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).nr_pages as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(nr_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).phys_addr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_struct>())).caller as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(caller)
        )
    );
}
impl Default for vm_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type smp_call_func_t = ::core::option::Option<unsafe extern "C" fn(info: *mut c_types::c_void)>;
extern "C" {
    pub fn on_each_cpu(
        func: smp_call_func_t,
        info: *mut c_types::c_void,
        wait: c_types::c_int,
    ) -> c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct idr {
    pub idr_rt: radix_tree_root,
    pub idr_base: c_types::c_uint,
    pub idr_next: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_idr() {
    assert_eq!(
        ::core::mem::size_of::<idr>(),
        24usize,
        concat!("Size of: ", stringify!(idr))
    );
    assert_eq!(
        ::core::mem::align_of::<idr>(),
        8usize,
        concat!("Alignment of ", stringify!(idr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idr>())).idr_rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idr),
            "::",
            stringify!(idr_rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idr>())).idr_base as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idr),
            "::",
            stringify!(idr_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<idr>())).idr_next as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(idr),
            "::",
            stringify!(idr_next)
        )
    );
}
impl Default for idr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[test]
fn bindgen_test_layout_kuid_t() {
    assert_eq!(
        ::core::mem::size_of::<kuid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kuid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kuid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kuid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kuid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kuid_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
#[test]
fn bindgen_test_layout_kgid_t() {
    assert_eq!(
        ::core::mem::size_of::<kgid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kgid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kgid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kgid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kgid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kgid_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_open_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_iattrs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_dir {
    pub subdirs: c_types::c_ulong,
    pub children: rb_root,
    pub root: *mut kernfs_root,
}
#[test]
fn bindgen_test_layout_kernfs_elem_dir() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_elem_dir>(),
        24usize,
        concat!("Size of: ", stringify!(kernfs_elem_dir))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_elem_dir>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_elem_dir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).subdirs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_dir),
            "::",
            stringify!(subdirs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).children as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_dir),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).root as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_dir),
            "::",
            stringify!(root)
        )
    );
}
impl Default for kernfs_elem_dir {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_symlink {
    pub target_kn: *mut kernfs_node,
}
#[test]
fn bindgen_test_layout_kernfs_elem_symlink() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_elem_symlink>(),
        8usize,
        concat!("Size of: ", stringify!(kernfs_elem_symlink))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_elem_symlink>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_elem_symlink))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_symlink>())).target_kn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_symlink),
            "::",
            stringify!(target_kn)
        )
    );
}
impl Default for kernfs_elem_symlink {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_attr {
    pub ops: *const kernfs_ops,
    pub open: *mut kernfs_open_node,
    pub size: loff_t,
    pub notify_next: *mut kernfs_node,
}
#[test]
fn bindgen_test_layout_kernfs_elem_attr() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_elem_attr>(),
        32usize,
        concat!("Size of: ", stringify!(kernfs_elem_attr))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_elem_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_elem_attr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).open as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).notify_next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_elem_attr),
            "::",
            stringify!(notify_next)
        )
    );
}
impl Default for kernfs_elem_attr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node_id {
    pub __bindgen_anon_1: kernfs_node_id__bindgen_ty_1,
    pub id: u64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernfs_node_id__bindgen_ty_1 {
    pub ino: u32,
    pub generation: u32,
}
#[test]
fn bindgen_test_layout_kernfs_node_id__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node_id__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(kernfs_node_id__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node_id__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(kernfs_node_id__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_node_id__bindgen_ty_1>())).ino as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node_id__bindgen_ty_1),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_node_id__bindgen_ty_1>())).generation as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node_id__bindgen_ty_1),
            "::",
            stringify!(generation)
        )
    );
}
#[test]
fn bindgen_test_layout_kernfs_node_id() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node_id>(),
        8usize,
        concat!("Size of: ", stringify!(kernfs_node_id))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node_id>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_node_id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node_id>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node_id),
            "::",
            stringify!(id)
        )
    );
}
impl Default for kernfs_node_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_node {
    pub count: atomic_t,
    pub active: atomic_t,
    pub parent: *mut kernfs_node,
    pub name: *const c_types::c_char,
    pub rb: rb_node,
    pub ns: *const c_types::c_void,
    pub hash: c_types::c_uint,
    pub __bindgen_anon_1: kernfs_node__bindgen_ty_1,
    pub priv_: *mut c_types::c_void,
    pub id: kernfs_node_id,
    pub flags: c_types::c_ushort,
    pub mode: umode_t,
    pub iattr: *mut kernfs_iattrs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node__bindgen_ty_1 {
    pub dir: kernfs_elem_dir,
    pub symlink: kernfs_elem_symlink,
    pub attr: kernfs_elem_attr,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_kernfs_node__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(kernfs_node__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_node__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).dir as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node__bindgen_ty_1),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).symlink as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node__bindgen_ty_1),
            "::",
            stringify!(symlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node__bindgen_ty_1),
            "::",
            stringify!(attr)
        )
    );
}
impl Default for kernfs_node__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_kernfs_node() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_node>(),
        128usize,
        concat!("Size of: ", stringify!(kernfs_node))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_node>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).active as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).rb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(rb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).ns as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).hash as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).priv_ as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).id as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).flags as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).mode as *const _ as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_node>())).iattr as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_node),
            "::",
            stringify!(iattr)
        )
    );
}
impl Default for kernfs_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernfs_syscall_ops {
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            root: *mut kernfs_root,
            flags: *mut c_types::c_int,
            data: *mut c_types::c_char,
        ) -> c_types::c_int,
    >,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, root: *mut kernfs_root) -> c_types::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            parent: *mut kernfs_node,
            name: *const c_types::c_char,
            mode: umode_t,
        ) -> c_types::c_int,
    >,
    pub rmdir: ::core::option::Option<unsafe extern "C" fn(kn: *mut kernfs_node) -> c_types::c_int>,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            kn: *mut kernfs_node,
            new_parent: *mut kernfs_node,
            new_name: *const c_types::c_char,
        ) -> c_types::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            kn: *mut kernfs_node,
            root: *mut kernfs_root,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_kernfs_syscall_ops() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_syscall_ops>(),
        48usize,
        concat!("Size of: ", stringify!(kernfs_syscall_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_syscall_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_syscall_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).remount_fs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(remount_fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_syscall_ops>())).show_options as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(show_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).mkdir as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).rmdir as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(rmdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).rename as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_syscall_ops>())).show_path as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_syscall_ops),
            "::",
            stringify!(show_path)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_root {
    pub kn: *mut kernfs_node,
    pub flags: c_types::c_uint,
    pub ino_idr: idr,
    pub last_ino: u32,
    pub next_generation: u32,
    pub syscall_ops: *mut kernfs_syscall_ops,
    pub supers: list_head,
    pub deactivate_waitq: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_kernfs_root() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_root>(),
        96usize,
        concat!("Size of: ", stringify!(kernfs_root))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_root>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).kn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(kn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).ino_idr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(ino_idr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).last_ino as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(last_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).next_generation as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(next_generation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).syscall_ops as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(syscall_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).supers as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(supers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_root>())).deactivate_waitq as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_root),
            "::",
            stringify!(deactivate_waitq)
        )
    );
}
impl Default for kernfs_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_file {
    pub kn: *mut kernfs_node,
    pub file: *mut file,
    pub seq_file: *mut seq_file,
    pub priv_: *mut c_types::c_void,
    pub mutex: mutex,
    pub prealloc_mutex: mutex,
    pub event: c_types::c_int,
    pub list: list_head,
    pub prealloc_buf: *mut c_types::c_char,
    pub atomic_write_len: usize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub vm_ops: *mut vm_operations_struct,
}
#[test]
fn bindgen_test_layout_kernfs_open_file() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_open_file>(),
        152usize,
        concat!("Size of: ", stringify!(kernfs_open_file))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_open_file>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_open_file))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).kn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(kn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).seq_file as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(seq_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_open_file>())).prealloc_mutex as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(prealloc_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).event as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).list as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).prealloc_buf as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(prealloc_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kernfs_open_file>())).atomic_write_len as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(atomic_write_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).vm_ops as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_open_file),
            "::",
            stringify!(vm_ops)
        )
    );
}
impl Default for kernfs_open_file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl kernfs_open_file {
    #[inline]
    pub fn mmapped(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmapped(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn released(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_released(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mmapped: bool_,
        released: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmapped: u8 = unsafe { ::core::mem::transmute(mmapped) };
            mmapped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let released: u8 = unsafe { ::core::mem::transmute(released) };
            released as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernfs_ops {
    pub open:
        ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> c_types::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut c_types::c_void) -> c_types::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut c_types::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut c_types::c_void,
            ppos: *mut loff_t,
        ) -> *mut c_types::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut c_types::c_void)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut c_types::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub atomic_write_len: usize,
    pub prealloc: bool_,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut c_types::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, vma: *mut vm_area_struct) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_kernfs_ops() {
    assert_eq!(
        ::core::mem::size_of::<kernfs_ops>(),
        88usize,
        concat!("Size of: ", stringify!(kernfs_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kernfs_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kernfs_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).open as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_show as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_start as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_stop as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(seq_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).read as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).atomic_write_len as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(atomic_write_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).prealloc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(prealloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).write as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernfs_ops>())).mmap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kernfs_ops),
            "::",
            stringify!(mmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock {
    _unused: [u8; 0],
}
pub const kobj_ns_type_KOBJ_NS_TYPE_NONE: kobj_ns_type = 0;
pub const kobj_ns_type_KOBJ_NS_TYPE_NET: kobj_ns_type = 1;
pub const kobj_ns_type_KOBJ_NS_TYPES: kobj_ns_type = 2;
pub type kobj_ns_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_ns_type_operations {
    pub type_: kobj_ns_type,
    pub current_may_mount: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub grab_current_ns: ::core::option::Option<unsafe extern "C" fn() -> *mut c_types::c_void>,
    pub netlink_ns:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> *const c_types::c_void>,
    pub initial_ns: ::core::option::Option<unsafe extern "C" fn() -> *const c_types::c_void>,
    pub drop_ns: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
}
#[test]
fn bindgen_test_layout_kobj_ns_type_operations() {
    assert_eq!(
        ::core::mem::size_of::<kobj_ns_type_operations>(),
        48usize,
        concat!("Size of: ", stringify!(kobj_ns_type_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<kobj_ns_type_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(kobj_ns_type_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_ns_type_operations>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).current_may_mount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(current_may_mount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).grab_current_ns as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(grab_current_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).netlink_ns as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(netlink_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).initial_ns as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(initial_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<kobj_ns_type_operations>())).drop_ns as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_ns_type_operations),
            "::",
            stringify!(drop_ns)
        )
    );
}
impl Default for kobj_ns_type_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kstat {
    pub result_mask: u32,
    pub mode: umode_t,
    pub nlink: c_types::c_uint,
    pub blksize: u32,
    pub attributes: u64,
    pub attributes_mask: u64,
    pub ino: u64,
    pub dev: dev_t,
    pub rdev: dev_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub atime: timespec64,
    pub mtime: timespec64,
    pub ctime: timespec64,
    pub btime: timespec64,
    pub blocks: u64,
}
#[test]
fn bindgen_test_layout_kstat() {
    assert_eq!(
        ::core::mem::size_of::<kstat>(),
        136usize,
        concat!("Size of: ", stringify!(kstat))
    );
    assert_eq!(
        ::core::mem::align_of::<kstat>(),
        8usize,
        concat!("Alignment of ", stringify!(kstat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).result_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(result_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).nlink as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).blksize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).attributes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).attributes_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(attributes_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).ino as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).dev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).rdev as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).uid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).gid as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).atime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).mtime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).ctime as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).btime as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kstat>())).blocks as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(blocks)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute {
    pub name: *const c_types::c_char,
    pub mode: umode_t,
}
#[test]
fn bindgen_test_layout_attribute() {
    assert_eq!(
        ::core::mem::size_of::<attribute>(),
        16usize,
        concat!("Size of: ", stringify!(attribute))
    );
    assert_eq!(
        ::core::mem::align_of::<attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(attribute))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<attribute>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attribute),
            "::",
            stringify!(mode)
        )
    );
}
impl Default for attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sysfs_ops {
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *mut c_types::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *const c_types::c_char,
            arg4: usize,
        ) -> isize,
    >,
}
#[test]
fn bindgen_test_layout_sysfs_ops() {
    assert_eq!(
        ::core::mem::size_of::<sysfs_ops>(),
        16usize,
        concat!("Size of: ", stringify!(sysfs_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<sysfs_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(sysfs_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysfs_ops>())).show as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysfs_ops),
            "::",
            stringify!(show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysfs_ops>())).store as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sysfs_ops),
            "::",
            stringify!(store)
        )
    );
}
#[doc = " struct refcount_t - variant of atomic_t specialized for reference counts"]
#[doc = " @refs: atomic_t counter field"]
#[doc = ""]
#[doc = " The counter saturates at UINT_MAX and will not move once"]
#[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
#[doc = " use-after-free bugs."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
#[test]
fn bindgen_test_layout_refcount_struct() {
    assert_eq!(
        ::core::mem::size_of::<refcount_struct>(),
        4usize,
        concat!("Size of: ", stringify!(refcount_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<refcount_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(refcount_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<refcount_struct>())).refs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(refcount_struct),
            "::",
            stringify!(refs)
        )
    );
}
#[doc = " struct refcount_t - variant of atomic_t specialized for reference counts"]
#[doc = " @refs: atomic_t counter field"]
#[doc = ""]
#[doc = " The counter saturates at UINT_MAX and will not move once"]
#[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
#[doc = " use-after-free bugs."]
pub type refcount_t = refcount_struct;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kref {
    pub refcount: refcount_t,
}
#[test]
fn bindgen_test_layout_kref() {
    assert_eq!(
        ::core::mem::size_of::<kref>(),
        4usize,
        concat!("Size of: ", stringify!(kref))
    );
    assert_eq!(
        ::core::mem::align_of::<kref>(),
        4usize,
        concat!("Alignment of ", stringify!(kref))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kref>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kref),
            "::",
            stringify!(refcount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobject {
    pub name: *const c_types::c_char,
    pub entry: list_head,
    pub parent: *mut kobject,
    pub kset: *mut kset,
    pub ktype: *mut kobj_type,
    pub sd: *mut kernfs_node,
    pub kref: kref,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_kobject() {
    assert_eq!(
        ::core::mem::size_of::<kobject>(),
        64usize,
        concat!("Size of: ", stringify!(kobject))
    );
    assert_eq!(
        ::core::mem::align_of::<kobject>(),
        8usize,
        concat!("Alignment of ", stringify!(kobject))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).kset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(kset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).ktype as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(ktype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).sd as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(sd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobject>())).kref as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kobject),
            "::",
            stringify!(kref)
        )
    );
}
impl Default for kobject {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl kobject {
    #[inline]
    pub fn state_initialized(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_initialized(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_in_sysfs(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_in_sysfs(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_add_uevent_sent(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_add_uevent_sent(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_remove_uevent_sent(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_remove_uevent_sent(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uevent_suppress(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uevent_suppress(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state_initialized: c_types::c_uint,
        state_in_sysfs: c_types::c_uint,
        state_add_uevent_sent: c_types::c_uint,
        state_remove_uevent_sent: c_types::c_uint,
        uevent_suppress: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let state_initialized: u32 = unsafe { ::core::mem::transmute(state_initialized) };
            state_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state_in_sysfs: u32 = unsafe { ::core::mem::transmute(state_in_sysfs) };
            state_in_sysfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let state_add_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_add_uevent_sent) };
            state_add_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_remove_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_remove_uevent_sent) };
            state_remove_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let uevent_suppress: u32 = unsafe { ::core::mem::transmute(uevent_suppress) };
            uevent_suppress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_type {
    pub release: ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject)>,
    pub sysfs_ops: *const sysfs_ops,
    pub default_attrs: *mut *mut attribute,
    pub child_ns_type: ::core::option::Option<
        unsafe extern "C" fn(kobj: *mut kobject) -> *const kobj_ns_type_operations,
    >,
    pub namespace:
        ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject) -> *const c_types::c_void>,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(kobj: *mut kobject, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
}
#[test]
fn bindgen_test_layout_kobj_type() {
    assert_eq!(
        ::core::mem::size_of::<kobj_type>(),
        48usize,
        concat!("Size of: ", stringify!(kobj_type))
    );
    assert_eq!(
        ::core::mem::align_of::<kobj_type>(),
        8usize,
        concat!("Alignment of ", stringify!(kobj_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).release as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).sysfs_ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(sysfs_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).default_attrs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(default_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).child_ns_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(child_ns_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).namespace as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(namespace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_type>())).get_ownership as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_type),
            "::",
            stringify!(get_ownership)
        )
    );
}
impl Default for kobj_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_uevent_env {
    pub argv: [*mut c_types::c_char; 3usize],
    pub envp: [*mut c_types::c_char; 32usize],
    pub envp_idx: c_types::c_int,
    pub buf: [c_types::c_char; 2048usize],
    pub buflen: c_types::c_int,
}
#[test]
fn bindgen_test_layout_kobj_uevent_env() {
    assert_eq!(
        ::core::mem::size_of::<kobj_uevent_env>(),
        2336usize,
        concat!("Size of: ", stringify!(kobj_uevent_env))
    );
    assert_eq!(
        ::core::mem::align_of::<kobj_uevent_env>(),
        8usize,
        concat!("Alignment of ", stringify!(kobj_uevent_env))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).argv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).envp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(envp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).envp_idx as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(envp_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).buf as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).buflen as *const _ as usize },
        2332usize,
        concat!(
            "Offset of field: ",
            stringify!(kobj_uevent_env),
            "::",
            stringify!(buflen)
        )
    );
}
impl Default for kobj_uevent_env {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kset_uevent_ops {
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(kset: *mut kset, kobj: *mut kobject) -> c_types::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(kset: *mut kset, kobj: *mut kobject) -> *const c_types::c_char,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(
            kset: *mut kset,
            kobj: *mut kobject,
            env: *mut kobj_uevent_env,
        ) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_kset_uevent_ops() {
    assert_eq!(
        ::core::mem::size_of::<kset_uevent_ops>(),
        24usize,
        concat!("Size of: ", stringify!(kset_uevent_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kset_uevent_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kset_uevent_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).filter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kset_uevent_ops),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kset_uevent_ops),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).uevent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kset_uevent_ops),
            "::",
            stringify!(uevent)
        )
    );
}
#[doc = " struct kset - a set of kobjects of a specific type, belonging to a specific subsystem."]
#[doc = ""]
#[doc = " A kset defines a group of kobjects.  They can be individually"]
#[doc = " different \"types\" but overall these kobjects all want to be grouped"]
#[doc = " together and operated on in the same manner.  ksets are used to"]
#[doc = " define the attribute callbacks and other common events that happen to"]
#[doc = " a kobject."]
#[doc = ""]
#[doc = " @list: the list of all kobjects for this kset"]
#[doc = " @list_lock: a lock for iterating over the kobjects"]
#[doc = " @kobj: the embedded kobject for this kset (recursion, isn't it fun...)"]
#[doc = " @uevent_ops: the set of uevent operations for this kset.  These are"]
#[doc = " called whenever a kobject has something happen to it so that the kset"]
#[doc = " can add new environment variables, or filter out the uevents if so"]
#[doc = " desired."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kset {
    pub list: list_head,
    pub list_lock: spinlock_t,
    pub kobj: kobject,
    pub uevent_ops: *const kset_uevent_ops,
}
#[test]
fn bindgen_test_layout_kset() {
    assert_eq!(
        ::core::mem::size_of::<kset>(),
        96usize,
        concat!("Size of: ", stringify!(kset))
    );
    assert_eq!(
        ::core::mem::align_of::<kset>(),
        8usize,
        concat!("Alignment of ", stringify!(kset))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).list_lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(list_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).kobj as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kset>())).uevent_ops as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(kset),
            "::",
            stringify!(uevent_ops)
        )
    );
}
impl Default for kset {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const pid_type_PIDTYPE_PID: pid_type = 0;
pub const pid_type_PIDTYPE_TGID: pid_type = 1;
pub const pid_type_PIDTYPE_PGID: pid_type = 2;
pub const pid_type_PIDTYPE_SID: pid_type = 3;
pub const pid_type_PIDTYPE_MAX: pid_type = 4;
pub type pid_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct upid {
    pub nr: c_types::c_int,
    pub ns: *mut pid_namespace,
}
#[test]
fn bindgen_test_layout_upid() {
    assert_eq!(
        ::core::mem::size_of::<upid>(),
        16usize,
        concat!("Size of: ", stringify!(upid))
    );
    assert_eq!(
        ::core::mem::align_of::<upid>(),
        8usize,
        concat!("Alignment of ", stringify!(upid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<upid>())).nr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(upid), "::", stringify!(nr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<upid>())).ns as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(upid), "::", stringify!(ns))
    );
}
impl Default for upid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pid {
    pub count: atomic_t,
    pub level: c_types::c_uint,
    pub tasks: [hlist_head; 4usize],
    pub rcu: callback_head,
    pub numbers: [upid; 1usize],
}
#[test]
fn bindgen_test_layout_pid() {
    assert_eq!(
        ::core::mem::size_of::<pid>(),
        72usize,
        concat!("Size of: ", stringify!(pid))
    );
    assert_eq!(
        ::core::mem::align_of::<pid>(),
        8usize,
        concat!("Alignment of ", stringify!(pid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).tasks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).rcu as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(pid), "::", stringify!(rcu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pid>())).numbers as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(numbers)
        )
    );
}
impl Default for pid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pid_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem_undo_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_sem {
    pub undo_list: *mut sem_undo_list,
}
#[test]
fn bindgen_test_layout_sysv_sem() {
    assert_eq!(
        ::core::mem::size_of::<sysv_sem>(),
        8usize,
        concat!("Size of: ", stringify!(sysv_sem))
    );
    assert_eq!(
        ::core::mem::align_of::<sysv_sem>(),
        8usize,
        concat!("Alignment of ", stringify!(sysv_sem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysv_sem>())).undo_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysv_sem),
            "::",
            stringify!(undo_list)
        )
    );
}
impl Default for sysv_sem {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_shm {
    pub shm_clist: list_head,
}
#[test]
fn bindgen_test_layout_sysv_shm() {
    assert_eq!(
        ::core::mem::size_of::<sysv_shm>(),
        16usize,
        concat!("Size of: ", stringify!(sysv_shm))
    );
    assert_eq!(
        ::core::mem::align_of::<sysv_shm>(),
        8usize,
        concat!("Alignment of ", stringify!(sysv_shm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysv_shm>())).shm_clist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysv_shm),
            "::",
            stringify!(shm_clist)
        )
    );
}
impl Default for sysv_shm {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plist_node {
    pub prio: c_types::c_int,
    pub prio_list: list_head,
    pub node_list: list_head,
}
#[test]
fn bindgen_test_layout_plist_node() {
    assert_eq!(
        ::core::mem::size_of::<plist_node>(),
        40usize,
        concat!("Size of: ", stringify!(plist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<plist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(plist_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<plist_node>())).prio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<plist_node>())).prio_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(prio_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<plist_node>())).node_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(node_list)
        )
    );
}
impl Default for plist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
#[test]
fn bindgen_test_layout_timerqueue_node() {
    assert_eq!(
        ::core::mem::size_of::<timerqueue_node>(),
        32usize,
        concat!("Size of: ", stringify!(timerqueue_node))
    );
    assert_eq!(
        ::core::mem::align_of::<timerqueue_node>(),
        8usize,
        concat!("Alignment of ", stringify!(timerqueue_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timerqueue_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timerqueue_node>())).expires as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_node),
            "::",
            stringify!(expires)
        )
    );
}
impl Default for timerqueue_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_head {
    pub head: rb_root,
    pub next: *mut timerqueue_node,
}
#[test]
fn bindgen_test_layout_timerqueue_head() {
    assert_eq!(
        ::core::mem::size_of::<timerqueue_head>(),
        16usize,
        concat!("Size of: ", stringify!(timerqueue_head))
    );
    assert_eq!(
        ::core::mem::align_of::<timerqueue_head>(),
        8usize,
        concat!("Alignment of ", stringify!(timerqueue_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timerqueue_head>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_head),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timerqueue_head>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_head),
            "::",
            stringify!(next)
        )
    );
}
impl Default for timerqueue_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const hrtimer_restart_HRTIMER_NORESTART: hrtimer_restart = 0;
pub const hrtimer_restart_HRTIMER_RESTART: hrtimer_restart = 1;
pub type hrtimer_restart = i32;
#[doc = " struct hrtimer - the basic hrtimer structure"]
#[doc = " @node:\ttimerqueue node, which also manages node.expires,"]
#[doc = "\t\tthe absolute expiry time in the hrtimers internal"]
#[doc = "\t\trepresentation. The time is related to the clock on"]
#[doc = "\t\twhich the timer is based. Is setup by adding"]
#[doc = "\t\tslack to the _softexpires value. For non range timers"]
#[doc = "\t\tidentical to _softexpires."]
#[doc = " @_softexpires: the absolute earliest expiry time of the hrtimer."]
#[doc = "\t\tThe time which was given as expiry time when the timer"]
#[doc = "\t\twas armed."]
#[doc = " @function:\ttimer expiry callback function"]
#[doc = " @base:\tpointer to the timer base (per cpu and per clock)"]
#[doc = " @state:\tstate information (See bit values above)"]
#[doc = " @is_rel:\tSet if the timer was armed relative"]
#[doc = " @is_soft:\tSet if hrtimer will be expired in soft interrupt context."]
#[doc = ""]
#[doc = " The hrtimer structure must be initialized by hrtimer_init()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8,
    pub is_rel: u8,
    pub is_soft: u8,
}
#[test]
fn bindgen_test_layout_hrtimer() {
    assert_eq!(
        ::core::mem::size_of::<hrtimer>(),
        64usize,
        concat!("Size of: ", stringify!(hrtimer))
    );
    assert_eq!(
        ::core::mem::align_of::<hrtimer>(),
        8usize,
        concat!("Alignment of ", stringify!(hrtimer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>()))._softexpires as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(_softexpires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).function as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).base as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).is_rel as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(is_rel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer>())).is_soft as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(is_soft)
        )
    );
}
impl Default for hrtimer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct hrtimer_clock_base - the timer base for a specific clock"]
#[doc = " @cpu_base:\t\tper cpu clock base"]
#[doc = " @index:\t\tclock type index for per_cpu support when moving a"]
#[doc = "\t\t\ttimer to a base on another cpu."]
#[doc = " @clockid:\t\tclock id for per_cpu support"]
#[doc = " @seq:\t\tseqcount around __run_hrtimer"]
#[doc = " @running:\t\tpointer to the currently running hrtimer"]
#[doc = " @active:\t\tred black tree root node for the active timers"]
#[doc = " @get_time:\t\tfunction to retrieve the current time of the clock"]
#[doc = " @offset:\t\toffset of this clock to the monotonic base"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: c_types::c_uint,
    pub clockid: clockid_t,
    pub seq: seqcount_t,
    pub running: *mut hrtimer,
    pub active: timerqueue_head,
    pub get_time: ::core::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
}
#[test]
fn bindgen_test_layout_hrtimer_clock_base() {
    assert_eq!(
        ::core::mem::size_of::<hrtimer_clock_base>(),
        64usize,
        concat!("Size of: ", stringify!(hrtimer_clock_base))
    );
    assert_eq!(
        ::core::mem::align_of::<hrtimer_clock_base>(),
        64usize,
        concat!("Alignment of ", stringify!(hrtimer_clock_base))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).cpu_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(cpu_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).clockid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).seq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).running as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).active as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).get_time as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(get_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).offset as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(offset)
        )
    );
}
impl Default for hrtimer_clock_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct hrtimer_cpu_base - the per cpu clock bases"]
#[doc = " @lock:\t\tlock protecting the base and associated clock bases"]
#[doc = "\t\t\tand timers"]
#[doc = " @cpu:\t\tcpu number"]
#[doc = " @active_bases:\tBitfield to mark bases with active timers"]
#[doc = " @clock_was_set_seq:\tSequence counter of clock was set events"]
#[doc = " @hres_active:\tState of high resolution mode"]
#[doc = " @in_hrtirq:\t\thrtimer_interrupt() is currently executing"]
#[doc = " @hang_detected:\tThe last hrtimer interrupt detected a hang"]
#[doc = " @softirq_activated:\tdisplays, if the softirq is raised - update of softirq"]
#[doc = "\t\t\trelated settings is not required then."]
#[doc = " @nr_events:\t\tTotal number of hrtimer interrupt events"]
#[doc = " @nr_retries:\t\tTotal number of hrtimer interrupt retries"]
#[doc = " @nr_hangs:\t\tTotal number of hrtimer interrupt hangs"]
#[doc = " @max_hang_time:\tMaximum time spent in hrtimer_interrupt"]
#[doc = " @expires_next:\tabsolute time of the next event, is required for remote"]
#[doc = "\t\t\thrtimer enqueue; it is the total first expiry time (hard"]
#[doc = "\t\t\tand soft hrtimer are taken into account)"]
#[doc = " @next_timer:\t\tPointer to the first expiring timer"]
#[doc = " @softirq_expires_next: Time to check, if soft queues needs also to be expired"]
#[doc = " @softirq_next_timer: Pointer to the first expiring softirq based timer"]
#[doc = " @clock_base:\t\tarray of clock bases for this cpu"]
#[doc = ""]
#[doc = " Note: next_timer is just an optimization for __remove_hrtimer()."]
#[doc = "\t Do not dereference the pointer because it is not reliable on"]
#[doc = "\t cross cpu removals."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub cpu: c_types::c_uint,
    pub active_bases: c_types::c_uint,
    pub clock_was_set_seq: c_types::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub nr_events: c_types::c_uint,
    pub nr_retries: c_types::c_ushort,
    pub nr_hangs: c_types::c_ushort,
    pub max_hang_time: c_types::c_uint,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub softirq_expires_next: ktime_t,
    pub softirq_next_timer: *mut hrtimer,
    pub clock_base: [hrtimer_clock_base; 8usize],
}
#[test]
fn bindgen_test_layout_hrtimer_cpu_base() {
    assert_eq!(
        ::core::mem::size_of::<hrtimer_cpu_base>(),
        576usize,
        concat!("Size of: ", stringify!(hrtimer_cpu_base))
    );
    assert_eq!(
        ::core::mem::align_of::<hrtimer_cpu_base>(),
        64usize,
        concat!("Alignment of ", stringify!(hrtimer_cpu_base))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).cpu as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).active_bases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(active_bases)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hrtimer_cpu_base>())).clock_was_set_seq as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(clock_was_set_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_events as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_retries as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_retries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_hangs as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_hangs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).max_hang_time as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(max_hang_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).expires_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(expires_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).next_timer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(next_timer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hrtimer_cpu_base>())).softirq_expires_next as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(softirq_expires_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hrtimer_cpu_base>())).softirq_next_timer as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(softirq_next_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).clock_base as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(clock_base)
        )
    );
}
impl Default for hrtimer_cpu_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn hres_active(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_hrtirq(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn softirq_activated(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_softirq_activated(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hres_active: c_types::c_uint,
        in_hrtirq: c_types::c_uint,
        hang_detected: c_types::c_uint,
        softirq_activated: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hres_active: u32 = unsafe { ::core::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::core::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::core::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let softirq_activated: u32 = unsafe { ::core::mem::transmute(softirq_activated) };
            softirq_activated as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp_filter {
    _unused: [u8; 0],
}
#[doc = " struct seccomp - the state of a seccomp'ed process"]
#[doc = ""]
#[doc = " @mode:  indicates one of the valid values above for controlled"]
#[doc = "         system calls available to a process."]
#[doc = " @filter: must always point to a valid seccomp-filter or NULL as it is"]
#[doc = "          accessed without locking during system call entry."]
#[doc = ""]
#[doc = "          @filter must only be accessed from the context of current as there"]
#[doc = "          is no read locking."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp {
    pub mode: c_types::c_int,
    pub filter: *mut seccomp_filter,
}
#[test]
fn bindgen_test_layout_seccomp() {
    assert_eq!(
        ::core::mem::size_of::<seccomp>(),
        16usize,
        concat!("Size of: ", stringify!(seccomp))
    );
    assert_eq!(
        ::core::mem::align_of::<seccomp>(),
        8usize,
        concat!("Alignment of ", stringify!(seccomp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seccomp>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<seccomp>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp),
            "::",
            stringify!(filter)
        )
    );
}
impl Default for seccomp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigset_t {
    pub sig: [c_types::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_sigset_t() {
    assert_eq!(
        ::core::mem::size_of::<sigset_t>(),
        8usize,
        concat!("Size of: ", stringify!(sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigset_t>())).sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigset_t),
            "::",
            stringify!(sig)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: c_types::c_int,
    pub sival_ptr: *mut c_types::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::core::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::core::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
impl Default for sigval {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo {
    pub si_signo: c_types::c_int,
    pub si_errno: c_types::c_int,
    pub si_code: c_types::c_int,
    pub _sifields: siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1 {
    pub _pad: [c_types::c_int; 28usize],
    pub _kill: siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>()))._pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>()))._uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: c_types::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: c_types::c_int,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_2>()))._tid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_2>()))._overrun as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_2>()))._sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_sigval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_2>()))._sys_private
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_sys_private)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_3>()))._pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_3>()))._uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_3>()))._sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_sigval)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: c_types::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_4>()))._pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_4>()))._uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_4>()))._status as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_4>()))._utime as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_utime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_4>()))._stime as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub _addr: *mut c_types::c_void,
    pub __bindgen_anon_1: siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_lsb: c_types::c_short,
    pub _addr_bnd: siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [c_types::c_char; 8usize],
    pub _lower: *mut c_types::c_void,
    pub _upper: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: core :: ptr :: null :: < siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _dummy_bnd as * const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_dummy_bnd)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: core :: ptr :: null :: < siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _lower as * const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: core :: ptr :: null :: < siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _upper as * const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [c_types::c_char; 8usize],
    pub _pkey: __u32,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: core :: ptr :: null :: < siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 > ( ) ) ) . _dummy_pkey as * const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_dummy_pkey)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: core :: ptr :: null :: < siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 > ( ) ) ) . _pkey as * const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._addr_lsb
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._addr_bnd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))
                ._addr_pkey as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_pkey)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_5>()))._addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_addr)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_6 {
    pub _band: c_types::c_long,
    pub _fd: c_types::c_int,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_6>()))._band as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(_band)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_6>()))._fd as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut c_types::c_void,
    pub _syscall: c_types::c_int,
    pub _arch: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_7))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_7>()))._call_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_7>()))._syscall as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_7>()))._arch as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._sigchld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._sigfault as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._sigpoll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo__bindgen_ty_1>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
impl Default for siginfo__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_siginfo() {
    assert_eq!(
        ::core::mem::size_of::<siginfo>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo>()))._sifields as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo),
            "::",
            stringify!(_sifields)
        )
    );
}
impl Default for siginfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type siginfo_t = siginfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigpending {
    pub list: list_head,
    pub signal: sigset_t,
}
#[test]
fn bindgen_test_layout_sigpending() {
    assert_eq!(
        ::core::mem::size_of::<sigpending>(),
        24usize,
        concat!("Size of: ", stringify!(sigpending))
    );
    assert_eq!(
        ::core::mem::align_of::<sigpending>(),
        8usize,
        concat!("Alignment of ", stringify!(sigpending))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigpending>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigpending),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigpending>())).signal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigpending),
            "::",
            stringify!(signal)
        )
    );
}
impl Default for sigpending {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_tlbflush_unmap_batch {
    pub cpumask: cpumask,
}
#[test]
fn bindgen_test_layout_arch_tlbflush_unmap_batch() {
    assert_eq!(
        ::core::mem::size_of::<arch_tlbflush_unmap_batch>(),
        1024usize,
        concat!("Size of: ", stringify!(arch_tlbflush_unmap_batch))
    );
    assert_eq!(
        ::core::mem::align_of::<arch_tlbflush_unmap_batch>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_tlbflush_unmap_batch))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arch_tlbflush_unmap_batch>())).cpumask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_tlbflush_unmap_batch),
            "::",
            stringify!(cpumask)
        )
    );
}
impl Default for arch_tlbflush_unmap_batch {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmacache {
    pub seqnum: u64,
    pub vmas: [*mut vm_area_struct; 4usize],
}
#[test]
fn bindgen_test_layout_vmacache() {
    assert_eq!(
        ::core::mem::size_of::<vmacache>(),
        40usize,
        concat!("Size of: ", stringify!(vmacache))
    );
    assert_eq!(
        ::core::mem::align_of::<vmacache>(),
        8usize,
        concat!("Alignment of ", stringify!(vmacache))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmacache>())).seqnum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmacache),
            "::",
            stringify!(seqnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vmacache>())).vmas as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmacache),
            "::",
            stringify!(vmas)
        )
    );
}
impl Default for vmacache {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_rss_stat {
    pub events: c_types::c_int,
    pub count: [c_types::c_int; 4usize],
}
#[test]
fn bindgen_test_layout_task_rss_stat() {
    assert_eq!(
        ::core::mem::size_of::<task_rss_stat>(),
        20usize,
        concat!("Size of: ", stringify!(task_rss_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<task_rss_stat>(),
        4usize,
        concat!("Alignment of ", stringify!(task_rss_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_rss_stat>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_rss_stat),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_rss_stat>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(task_rss_stat),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mm_rss_stat {
    pub count: [atomic_long_t; 4usize],
}
#[test]
fn bindgen_test_layout_mm_rss_stat() {
    assert_eq!(
        ::core::mem::size_of::<mm_rss_stat>(),
        32usize,
        concat!("Size of: ", stringify!(mm_rss_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_rss_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_rss_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_rss_stat>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_rss_stat),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_frag {
    pub page: *mut page,
    pub offset: __u32,
    pub size: __u32,
}
#[test]
fn bindgen_test_layout_page_frag() {
    assert_eq!(
        ::core::mem::size_of::<page_frag>(),
        16usize,
        concat!("Size of: ", stringify!(page_frag))
    );
    assert_eq!(
        ::core::mem::align_of::<page_frag>(),
        8usize,
        concat!("Alignment of ", stringify!(page_frag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_frag>())).page as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_frag>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page_frag>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(size)
        )
    );
}
impl Default for page_frag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tlbflush_unmap_batch {
    pub arch: arch_tlbflush_unmap_batch,
    pub flush_required: bool_,
    pub writable: bool_,
}
#[test]
fn bindgen_test_layout_tlbflush_unmap_batch() {
    assert_eq!(
        ::core::mem::size_of::<tlbflush_unmap_batch>(),
        1032usize,
        concat!("Size of: ", stringify!(tlbflush_unmap_batch))
    );
    assert_eq!(
        ::core::mem::align_of::<tlbflush_unmap_batch>(),
        8usize,
        concat!("Alignment of ", stringify!(tlbflush_unmap_batch))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tlbflush_unmap_batch>())).arch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tlbflush_unmap_batch>())).flush_required as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(flush_required)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tlbflush_unmap_batch>())).writable as *const _ as usize },
        1025usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(writable)
        )
    );
}
impl Default for tlbflush_unmap_batch {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_io_accounting {
    pub rchar: u64,
    pub wchar: u64,
    pub syscr: u64,
    pub syscw: u64,
    pub read_bytes: u64,
    pub write_bytes: u64,
    pub cancelled_write_bytes: u64,
}
#[test]
fn bindgen_test_layout_task_io_accounting() {
    assert_eq!(
        ::core::mem::size_of::<task_io_accounting>(),
        56usize,
        concat!("Size of: ", stringify!(task_io_accounting))
    );
    assert_eq!(
        ::core::mem::align_of::<task_io_accounting>(),
        8usize,
        concat!("Alignment of ", stringify!(task_io_accounting))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).rchar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(rchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).wchar as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).syscr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(syscr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).syscw as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(syscw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).read_bytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(read_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_io_accounting>())).write_bytes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(write_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_io_accounting>())).cancelled_write_bytes as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(cancelled_write_bytes)
        )
    );
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct rseq {
    pub cpu_id_start: __u32,
    pub cpu_id: __u32,
    pub rseq_cs: rseq__bindgen_ty_1,
    pub flags: __u32,
    pub __bindgen_padding_0: [u32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rseq__bindgen_ty_1 {
    pub ptr64: __u64,
    pub ptr: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rseq__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<rseq__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rseq__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<rseq__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rseq__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq__bindgen_ty_1>())).ptr64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq__bindgen_ty_1),
            "::",
            stringify!(ptr64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
impl Default for rseq__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rseq() {
    assert_eq!(
        ::core::mem::size_of::<rseq>(),
        32usize,
        concat!("Size of: ", stringify!(rseq))
    );
    assert_eq!(
        ::core::mem::align_of::<rseq>(),
        32usize,
        concat!("Alignment of ", stringify!(rseq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq>())).cpu_id_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(cpu_id_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq>())).cpu_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(cpu_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq>())).rseq_cs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(rseq_cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rseq>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for rseq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct backing_dev_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_plug {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfs_rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futex_pi_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mempolicy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nameidata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsproxy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipe_inode_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reclaim_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct robust_list_head {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sighand_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_delay_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_group {
    _unused: [u8; 0],
}
#[doc = " struct prev_cputime - snapshot of system and user cputime"]
#[doc = " @utime: time spent in user mode"]
#[doc = " @stime: time spent in system mode"]
#[doc = " @lock: protects the above two fields"]
#[doc = ""]
#[doc = " Stores previous user/system time values such that we can guarantee"]
#[doc = " monotonicity."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prev_cputime {
    pub utime: u64,
    pub stime: u64,
    pub lock: raw_spinlock_t,
}
#[test]
fn bindgen_test_layout_prev_cputime() {
    assert_eq!(
        ::core::mem::size_of::<prev_cputime>(),
        24usize,
        concat!("Size of: ", stringify!(prev_cputime))
    );
    assert_eq!(
        ::core::mem::align_of::<prev_cputime>(),
        8usize,
        concat!("Alignment of ", stringify!(prev_cputime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<prev_cputime>())).utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<prev_cputime>())).stime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<prev_cputime>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(lock)
        )
    );
}
impl Default for prev_cputime {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct task_cputime - collected CPU time counts"]
#[doc = " @utime:\t\ttime spent in user mode, in nanoseconds"]
#[doc = " @stime:\t\ttime spent in kernel mode, in nanoseconds"]
#[doc = " @sum_exec_runtime:\ttotal time spent on the CPU, in nanoseconds"]
#[doc = ""]
#[doc = " This structure groups together three kinds of CPU time that are tracked for"]
#[doc = " threads and thread groups.  Most things considering CPU time want to group"]
#[doc = " these counts together and treat all three of them in parallel."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_cputime {
    pub utime: u64,
    pub stime: u64,
    pub sum_exec_runtime: c_types::c_ulonglong,
}
#[test]
fn bindgen_test_layout_task_cputime() {
    assert_eq!(
        ::core::mem::size_of::<task_cputime>(),
        24usize,
        concat!("Size of: ", stringify!(task_cputime))
    );
    assert_eq!(
        ::core::mem::align_of::<task_cputime>(),
        8usize,
        concat!("Alignment of ", stringify!(task_cputime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_cputime>())).utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_cputime>())).stime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_cputime>())).sum_exec_runtime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(sum_exec_runtime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_info {
    pub pcount: c_types::c_ulong,
    pub run_delay: c_types::c_ulonglong,
    pub last_arrival: c_types::c_ulonglong,
    pub last_queued: c_types::c_ulonglong,
}
#[test]
fn bindgen_test_layout_sched_info() {
    assert_eq!(
        ::core::mem::size_of::<sched_info>(),
        32usize,
        concat!("Size of: ", stringify!(sched_info))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_info>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).pcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(pcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).run_delay as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(run_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).last_arrival as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(last_arrival)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_info>())).last_queued as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(last_queued)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct load_weight {
    pub weight: c_types::c_ulong,
    pub inv_weight: u32,
}
#[test]
fn bindgen_test_layout_load_weight() {
    assert_eq!(
        ::core::mem::size_of::<load_weight>(),
        16usize,
        concat!("Size of: ", stringify!(load_weight))
    );
    assert_eq!(
        ::core::mem::align_of::<load_weight>(),
        8usize,
        concat!("Alignment of ", stringify!(load_weight))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<load_weight>())).weight as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(load_weight),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<load_weight>())).inv_weight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(load_weight),
            "::",
            stringify!(inv_weight)
        )
    );
}
#[doc = " struct util_est - Estimation utilization of FAIR tasks"]
#[doc = " @enqueued: instantaneous estimated utilization of a task/cpu"]
#[doc = " @ewma:     the Exponential Weighted Moving Average (EWMA)"]
#[doc = "            utilization of a task"]
#[doc = ""]
#[doc = " Support data structure to track an Exponential Weighted Moving Average"]
#[doc = " (EWMA) of a FAIR task's utilization. New samples are added to the moving"]
#[doc = " average each time a task completes an activation. Sample's weight is chosen"]
#[doc = " so that the EWMA will be relatively insensitive to transient changes to the"]
#[doc = " task's workload."]
#[doc = ""]
#[doc = " The enqueued attribute has a slightly different meaning for tasks and cpus:"]
#[doc = " - task:   the task's util_avg at last task dequeue time"]
#[doc = " - cfs_rq: the sum of util_est.enqueued for each RUNNABLE task on that CPU"]
#[doc = " Thus, the util_est.enqueued of a task represents the contribution on the"]
#[doc = " estimated utilization of the CPU where that task is currently enqueued."]
#[doc = ""]
#[doc = " Only for tasks we track a moving average of the past instantaneous"]
#[doc = " estimated utilization. This allows to absorb sporadic drops in utilization"]
#[doc = " of an otherwise almost periodic task."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct util_est {
    pub enqueued: c_types::c_uint,
    pub ewma: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_util_est() {
    assert_eq!(
        ::core::mem::size_of::<util_est>(),
        8usize,
        concat!("Size of: ", stringify!(util_est))
    );
    assert_eq!(
        ::core::mem::align_of::<util_est>(),
        8usize,
        concat!("Alignment of ", stringify!(util_est))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<util_est>())).enqueued as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(util_est),
            "::",
            stringify!(enqueued)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<util_est>())).ewma as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(util_est),
            "::",
            stringify!(ewma)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_avg {
    pub last_update_time: u64,
    pub load_sum: u64,
    pub runnable_load_sum: u64,
    pub util_sum: u32,
    pub period_contrib: u32,
    pub load_avg: c_types::c_ulong,
    pub runnable_load_avg: c_types::c_ulong,
    pub util_avg: c_types::c_ulong,
    pub util_est: util_est,
}
#[test]
fn bindgen_test_layout_sched_avg() {
    assert_eq!(
        ::core::mem::size_of::<sched_avg>(),
        64usize,
        concat!("Size of: ", stringify!(sched_avg))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_avg>(),
        64usize,
        concat!("Alignment of ", stringify!(sched_avg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).last_update_time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(last_update_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).load_sum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(load_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).runnable_load_sum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(runnable_load_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).util_sum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(util_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).period_contrib as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(period_contrib)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).load_avg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(load_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).runnable_load_avg as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(runnable_load_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).util_avg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(util_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_avg>())).util_est as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(util_est)
        )
    );
}
impl Default for sched_avg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_statistics {
    pub wait_start: u64,
    pub wait_max: u64,
    pub wait_count: u64,
    pub wait_sum: u64,
    pub iowait_count: u64,
    pub iowait_sum: u64,
    pub sleep_start: u64,
    pub sleep_max: u64,
    pub sum_sleep_runtime: s64,
    pub block_start: u64,
    pub block_max: u64,
    pub exec_max: u64,
    pub slice_max: u64,
    pub nr_migrations_cold: u64,
    pub nr_failed_migrations_affine: u64,
    pub nr_failed_migrations_running: u64,
    pub nr_failed_migrations_hot: u64,
    pub nr_forced_migrations: u64,
    pub nr_wakeups: u64,
    pub nr_wakeups_sync: u64,
    pub nr_wakeups_migrate: u64,
    pub nr_wakeups_local: u64,
    pub nr_wakeups_remote: u64,
    pub nr_wakeups_affine: u64,
    pub nr_wakeups_affine_attempts: u64,
    pub nr_wakeups_passive: u64,
    pub nr_wakeups_idle: u64,
}
#[test]
fn bindgen_test_layout_sched_statistics() {
    assert_eq!(
        ::core::mem::size_of::<sched_statistics>(),
        216usize,
        concat!("Size of: ", stringify!(sched_statistics))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_statistics>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_statistics))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_sum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).iowait_count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(iowait_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).iowait_sum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(iowait_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).sleep_start as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sleep_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).sleep_max as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sleep_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).sum_sleep_runtime as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sum_sleep_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).block_start as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(block_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).block_max as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).exec_max as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(exec_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).slice_max as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(slice_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_migrations_cold as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_migrations_cold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_affine as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_affine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_running as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_running)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_hot as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_hot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_forced_migrations as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_forced_migrations)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_sync as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_migrate as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_migrate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_local as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_local)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_remote as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_remote)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_affine as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_affine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_affine_attempts as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_affine_attempts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_passive as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_passive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_idle as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_idle)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_entity {
    pub load: load_weight,
    pub runnable_weight: c_types::c_ulong,
    pub run_node: rb_node,
    pub group_node: list_head,
    pub on_rq: c_types::c_uint,
    pub exec_start: u64,
    pub sum_exec_runtime: u64,
    pub vruntime: u64,
    pub prev_sum_exec_runtime: u64,
    pub nr_migrations: u64,
    pub statistics: sched_statistics,
    pub depth: c_types::c_int,
    pub parent: *mut sched_entity,
    pub cfs_rq: *mut cfs_rq,
    pub my_q: *mut cfs_rq,
    pub __bindgen_padding_0: [u64; 3usize],
    pub avg: sched_avg,
}
#[test]
fn bindgen_test_layout_sched_entity() {
    assert_eq!(
        ::core::mem::size_of::<sched_entity>(),
        448usize,
        concat!("Size of: ", stringify!(sched_entity))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_entity>(),
        64usize,
        concat!("Alignment of ", stringify!(sched_entity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).load as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).runnable_weight as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(runnable_weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).run_node as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(run_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).group_node as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(group_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).on_rq as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).exec_start as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(exec_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).sum_exec_runtime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(sum_exec_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).vruntime as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(vruntime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sched_entity>())).prev_sum_exec_runtime as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(prev_sum_exec_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).nr_migrations as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(nr_migrations)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).statistics as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(statistics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).depth as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).parent as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).cfs_rq as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(cfs_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).my_q as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(my_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_entity>())).avg as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(avg)
        )
    );
}
impl Default for sched_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_rt_entity {
    pub run_list: list_head,
    pub timeout: c_types::c_ulong,
    pub watchdog_stamp: c_types::c_ulong,
    pub time_slice: c_types::c_uint,
    pub on_rq: c_types::c_ushort,
    pub on_list: c_types::c_ushort,
    pub back: *mut sched_rt_entity,
    pub parent: *mut sched_rt_entity,
    pub rt_rq: *mut rt_rq,
    pub my_q: *mut rt_rq,
}
#[test]
fn bindgen_test_layout_sched_rt_entity() {
    assert_eq!(
        ::core::mem::size_of::<sched_rt_entity>(),
        72usize,
        concat!("Size of: ", stringify!(sched_rt_entity))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_rt_entity>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_rt_entity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).run_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(run_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).timeout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).watchdog_stamp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(watchdog_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).time_slice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(time_slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).on_rq as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).on_list as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(on_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).back as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(back)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).parent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).rt_rq as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(rt_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).my_q as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(my_q)
        )
    );
}
impl Default for sched_rt_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_dl_entity {
    pub rb_node: rb_node,
    pub dl_runtime: u64,
    pub dl_deadline: u64,
    pub dl_period: u64,
    pub dl_bw: u64,
    pub dl_density: u64,
    pub runtime: s64,
    pub deadline: u64,
    pub flags: c_types::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub dl_timer: hrtimer,
    pub inactive_timer: hrtimer,
}
#[test]
fn bindgen_test_layout_sched_dl_entity() {
    assert_eq!(
        ::core::mem::size_of::<sched_dl_entity>(),
        216usize,
        concat!("Size of: ", stringify!(sched_dl_entity))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_dl_entity>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_dl_entity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(rb_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_runtime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_deadline as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_period as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_bw as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_bw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_density as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_density)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).runtime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).deadline as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_timer as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).inactive_timer as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(inactive_timer)
        )
    );
}
impl Default for sched_dl_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sched_dl_entity {
    #[inline]
    pub fn dl_throttled(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_throttled(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_boosted(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_boosted(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_yielded(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_yielded(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_non_contending(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_non_contending(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_overrun(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_overrun(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dl_throttled: c_types::c_uint,
        dl_boosted: c_types::c_uint,
        dl_yielded: c_types::c_uint,
        dl_non_contending: c_types::c_uint,
        dl_overrun: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dl_throttled: u32 = unsafe { ::core::mem::transmute(dl_throttled) };
            dl_throttled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl_boosted: u32 = unsafe { ::core::mem::transmute(dl_boosted) };
            dl_boosted as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl_yielded: u32 = unsafe { ::core::mem::transmute(dl_yielded) };
            dl_yielded as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dl_non_contending: u32 = unsafe { ::core::mem::transmute(dl_non_contending) };
            dl_non_contending as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dl_overrun: u32 = unsafe { ::core::mem::transmute(dl_overrun) };
            dl_overrun as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_q_node {
    pub next: *mut wake_q_node,
}
#[test]
fn bindgen_test_layout_wake_q_node() {
    assert_eq!(
        ::core::mem::size_of::<wake_q_node>(),
        8usize,
        concat!("Size of: ", stringify!(wake_q_node))
    );
    assert_eq!(
        ::core::mem::align_of::<wake_q_node>(),
        8usize,
        concat!("Alignment of ", stringify!(wake_q_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<wake_q_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wake_q_node),
            "::",
            stringify!(next)
        )
    );
}
impl Default for wake_q_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct task_struct {
    pub thread_info: thread_info,
    pub state: c_types::c_long,
    pub stack: *mut c_types::c_void,
    pub usage: atomic_t,
    pub flags: c_types::c_uint,
    pub ptrace: c_types::c_uint,
    pub wake_entry: llist_node,
    pub on_cpu: c_types::c_int,
    pub cpu: c_types::c_uint,
    pub wakee_flips: c_types::c_uint,
    pub wakee_flip_decay_ts: c_types::c_ulong,
    pub last_wakee: *mut task_struct,
    pub recent_used_cpu: c_types::c_int,
    pub wake_cpu: c_types::c_int,
    pub on_rq: c_types::c_int,
    pub prio: c_types::c_int,
    pub static_prio: c_types::c_int,
    pub normal_prio: c_types::c_int,
    pub rt_priority: c_types::c_uint,
    pub sched_class: *mut sched_class,
    pub se: sched_entity,
    pub rt: sched_rt_entity,
    pub sched_task_group: *mut task_group,
    pub dl: sched_dl_entity,
    pub preempt_notifiers: hlist_head,
    pub btrace_seq: c_types::c_uint,
    pub policy: c_types::c_uint,
    pub nr_cpus_allowed: c_types::c_int,
    pub cpus_allowed: cpumask_t,
    pub rcu_tasks_nvcsw: c_types::c_ulong,
    pub rcu_tasks_holdout: u8,
    pub rcu_tasks_idx: u8,
    pub rcu_tasks_idle_cpu: c_types::c_int,
    pub rcu_tasks_holdout_list: list_head,
    pub sched_info: sched_info,
    pub tasks: list_head,
    pub pushable_tasks: plist_node,
    pub pushable_dl_tasks: rb_node,
    pub mm: *mut mm_struct,
    pub active_mm: *mut mm_struct,
    pub vmacache: vmacache,
    pub rss_stat: task_rss_stat,
    pub exit_state: c_types::c_int,
    pub exit_code: c_types::c_int,
    pub exit_signal: c_types::c_int,
    pub pdeath_signal: c_types::c_int,
    pub jobctl: c_types::c_ulong,
    pub personality: c_types::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize], u8>,
    pub atomic_flags: c_types::c_ulong,
    pub restart_block: restart_block,
    pub pid: pid_t,
    pub tgid: pid_t,
    pub stack_canary: c_types::c_ulong,
    pub real_parent: *mut task_struct,
    pub parent: *mut task_struct,
    pub children: list_head,
    pub sibling: list_head,
    pub group_leader: *mut task_struct,
    pub ptraced: list_head,
    pub ptrace_entry: list_head,
    pub thread_pid: *mut pid,
    pub pid_links: [hlist_node; 4usize],
    pub thread_group: list_head,
    pub thread_node: list_head,
    pub vfork_done: *mut completion,
    pub set_child_tid: *mut c_types::c_int,
    pub clear_child_tid: *mut c_types::c_int,
    pub utime: u64,
    pub stime: u64,
    pub gtime: u64,
    pub prev_cputime: prev_cputime,
    pub nvcsw: c_types::c_ulong,
    pub nivcsw: c_types::c_ulong,
    pub start_time: u64,
    pub real_start_time: u64,
    pub min_flt: c_types::c_ulong,
    pub maj_flt: c_types::c_ulong,
    pub cputime_expires: task_cputime,
    pub cpu_timers: [list_head; 3usize],
    pub ptracer_cred: *const cred,
    pub real_cred: *const cred,
    pub cred: *const cred,
    pub comm: [c_types::c_char; 16usize],
    pub nameidata: *mut nameidata,
    pub sysvsem: sysv_sem,
    pub sysvshm: sysv_shm,
    pub last_switch_count: c_types::c_ulong,
    pub last_switch_time: c_types::c_ulong,
    pub fs: *mut fs_struct,
    pub files: *mut files_struct,
    pub nsproxy: *mut nsproxy,
    pub signal: *mut signal_struct,
    pub sighand: *mut sighand_struct,
    pub blocked: sigset_t,
    pub real_blocked: sigset_t,
    pub saved_sigmask: sigset_t,
    pub pending: sigpending,
    pub sas_ss_sp: c_types::c_ulong,
    pub sas_ss_size: usize,
    pub sas_ss_flags: c_types::c_uint,
    pub task_works: *mut callback_head,
    pub audit_context: *mut audit_context,
    pub loginuid: kuid_t,
    pub sessionid: c_types::c_uint,
    pub seccomp: seccomp,
    pub parent_exec_id: u64,
    pub self_exec_id: u64,
    pub alloc_lock: spinlock_t,
    pub pi_lock: raw_spinlock_t,
    pub wake_q: wake_q_node,
    pub pi_waiters: rb_root_cached,
    pub pi_top_task: *mut task_struct,
    pub pi_blocked_on: *mut rt_mutex_waiter,
    pub journal_info: *mut c_types::c_void,
    pub bio_list: *mut bio_list,
    pub plug: *mut blk_plug,
    pub reclaim_state: *mut reclaim_state,
    pub backing_dev_info: *mut backing_dev_info,
    pub io_context: *mut io_context,
    pub ptrace_message: c_types::c_ulong,
    pub last_siginfo: *mut siginfo_t,
    pub ioac: task_io_accounting,
    pub acct_rss_mem1: u64,
    pub acct_vm_mem1: u64,
    pub acct_timexpd: u64,
    pub mems_allowed: nodemask_t,
    pub mems_allowed_seq: seqcount_t,
    pub cpuset_mem_spread_rotor: c_types::c_int,
    pub cpuset_slab_spread_rotor: c_types::c_int,
    pub cgroups: *mut css_set,
    pub cg_list: list_head,
    pub closid: u32,
    pub rmid: u32,
    pub robust_list: *mut robust_list_head,
    pub compat_robust_list: *mut compat_robust_list_head,
    pub pi_state_list: list_head,
    pub pi_state_cache: *mut futex_pi_state,
    pub perf_event_ctxp: [*mut perf_event_context; 2usize],
    pub perf_event_mutex: mutex,
    pub perf_event_list: list_head,
    pub mempolicy: *mut mempolicy,
    pub il_prev: c_types::c_short,
    pub pref_node_fork: c_types::c_short,
    pub numa_scan_seq: c_types::c_int,
    pub numa_scan_period: c_types::c_uint,
    pub numa_scan_period_max: c_types::c_uint,
    pub numa_preferred_nid: c_types::c_int,
    pub numa_migrate_retry: c_types::c_ulong,
    pub node_stamp: u64,
    pub last_task_numa_placement: u64,
    pub last_sum_exec_runtime: u64,
    pub numa_work: callback_head,
    pub numa_group: *mut numa_group,
    pub numa_faults: *mut c_types::c_ulong,
    pub total_numa_faults: c_types::c_ulong,
    pub numa_faults_locality: [c_types::c_ulong; 3usize],
    pub numa_pages_migrated: c_types::c_ulong,
    pub rseq: *mut rseq,
    pub rseq_len: u32,
    pub rseq_sig: u32,
    pub rseq_event_mask: c_types::c_ulong,
    pub tlb_ubc: tlbflush_unmap_batch,
    pub rcu: callback_head,
    pub splice_pipe: *mut pipe_inode_info,
    pub task_frag: page_frag,
    pub delays: *mut task_delay_info,
    pub nr_dirtied: c_types::c_int,
    pub nr_dirtied_pause: c_types::c_int,
    pub dirty_paused_when: c_types::c_ulong,
    pub timer_slack_ns: u64,
    pub default_timer_slack_ns: u64,
    pub curr_ret_stack: c_types::c_int,
    pub curr_ret_depth: c_types::c_int,
    pub ret_stack: *mut ftrace_ret_stack,
    pub ftrace_timestamp: c_types::c_ulonglong,
    pub trace_overrun: atomic_t,
    pub tracing_graph_pause: atomic_t,
    pub trace: c_types::c_ulong,
    pub trace_recursion: c_types::c_ulong,
    pub memcg_in_oom: *mut mem_cgroup,
    pub memcg_oom_gfp_mask: gfp_t,
    pub memcg_oom_order: c_types::c_int,
    pub memcg_nr_pages_over_high: c_types::c_uint,
    pub active_memcg: *mut mem_cgroup,
    pub throttle_queue: *mut request_queue,
    pub utask: *mut uprobe_task,
    pub sequential_io: c_types::c_uint,
    pub sequential_io_avg: c_types::c_uint,
    pub pagefault_disabled: c_types::c_int,
    pub oom_reaper_list: *mut task_struct,
    pub stack_vm_area: *mut vm_struct,
    pub stack_refcount: atomic_t,
    pub patch_state: c_types::c_int,
    pub security: *mut c_types::c_void,
    pub __bindgen_padding_0: [u64; 2usize],
    pub thread: thread_struct,
}
#[test]
fn bindgen_test_layout_task_struct() {
    assert_eq!(
        ::core::mem::size_of::<task_struct>(),
        9152usize,
        concat!("Size of: ", stringify!(task_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<task_struct>(),
        64usize,
        concat!("Alignment of ", stringify!(task_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).usage as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wake_entry as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).on_cpu as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(on_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cpu as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wakee_flips as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wakee_flips)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).wakee_flip_decay_ts as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wakee_flip_decay_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).last_wakee as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_wakee)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).recent_used_cpu as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(recent_used_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wake_cpu as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).on_rq as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).prio as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).static_prio as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(static_prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).normal_prio as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(normal_prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rt_priority as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rt_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sched_class as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).se as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(se)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rt as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sched_task_group as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_task_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).dl as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(dl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).preempt_notifiers as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(preempt_notifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).btrace_seq as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(btrace_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).policy as *const _ as usize },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nr_cpus_allowed as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_cpus_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cpus_allowed as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpus_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_nvcsw as *const _ as usize },
        1920usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_holdout as *const _ as usize },
        1928usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_holdout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_idx as *const _ as usize },
        1929usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_idle_cpu as *const _ as usize },
        1932usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_idle_cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).rcu_tasks_holdout_list as *const _ as usize
        },
        1936usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_holdout_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sched_info as *const _ as usize },
        1952usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).tasks as *const _ as usize },
        1984usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pushable_tasks as *const _ as usize },
        2000usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pushable_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pushable_dl_tasks as *const _ as usize },
        2040usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pushable_dl_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mm as *const _ as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).active_mm as *const _ as usize },
        2072usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(active_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).vmacache as *const _ as usize },
        2080usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(vmacache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rss_stat as *const _ as usize },
        2120usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rss_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).exit_state as *const _ as usize },
        2140usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).exit_code as *const _ as usize },
        2144usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).exit_signal as *const _ as usize },
        2148usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pdeath_signal as *const _ as usize },
        2152usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pdeath_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).jobctl as *const _ as usize },
        2160usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(jobctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).personality as *const _ as usize },
        2168usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(personality)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).atomic_flags as *const _ as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(atomic_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).restart_block as *const _ as usize },
        2192usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(restart_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pid as *const _ as usize },
        2240usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).tgid as *const _ as usize },
        2244usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack_canary as *const _ as usize },
        2248usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_parent as *const _ as usize },
        2256usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).parent as *const _ as usize },
        2264usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).children as *const _ as usize },
        2272usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sibling as *const _ as usize },
        2288usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).group_leader as *const _ as usize },
        2304usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(group_leader)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptraced as *const _ as usize },
        2312usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptraced)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace_entry as *const _ as usize },
        2328usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread_pid as *const _ as usize },
        2344usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pid_links as *const _ as usize },
        2352usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pid_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread_group as *const _ as usize },
        2416usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread_node as *const _ as usize },
        2432usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).vfork_done as *const _ as usize },
        2448usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(vfork_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).set_child_tid as *const _ as usize },
        2456usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(set_child_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).clear_child_tid as *const _ as usize },
        2464usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(clear_child_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).utime as *const _ as usize },
        2472usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stime as *const _ as usize },
        2480usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).gtime as *const _ as usize },
        2488usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(gtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).prev_cputime as *const _ as usize },
        2496usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(prev_cputime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nvcsw as *const _ as usize },
        2520usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nivcsw as *const _ as usize },
        2528usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nivcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).start_time as *const _ as usize },
        2536usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_start_time as *const _ as usize },
        2544usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).min_flt as *const _ as usize },
        2552usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(min_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).maj_flt as *const _ as usize },
        2560usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(maj_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cputime_expires as *const _ as usize },
        2568usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cputime_expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cpu_timers as *const _ as usize },
        2592usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpu_timers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptracer_cred as *const _ as usize },
        2640usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptracer_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_cred as *const _ as usize },
        2648usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cred as *const _ as usize },
        2656usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).comm as *const _ as usize },
        2664usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(comm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nameidata as *const _ as usize },
        2680usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nameidata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sysvsem as *const _ as usize },
        2688usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sysvsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sysvshm as *const _ as usize },
        2696usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sysvshm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).last_switch_count as *const _ as usize },
        2712usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_switch_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).last_switch_time as *const _ as usize },
        2720usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_switch_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).fs as *const _ as usize },
        2728usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).files as *const _ as usize },
        2736usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nsproxy as *const _ as usize },
        2744usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nsproxy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).signal as *const _ as usize },
        2752usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sighand as *const _ as usize },
        2760usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sighand)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).blocked as *const _ as usize },
        2768usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(blocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).real_blocked as *const _ as usize },
        2776usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_blocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).saved_sigmask as *const _ as usize },
        2784usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(saved_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pending as *const _ as usize },
        2792usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_sp as *const _ as usize },
        2816usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_size as *const _ as usize },
        2824usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_flags as *const _ as usize },
        2832usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).task_works as *const _ as usize },
        2840usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(task_works)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).audit_context as *const _ as usize },
        2848usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(audit_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).loginuid as *const _ as usize },
        2856usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(loginuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sessionid as *const _ as usize },
        2860usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sessionid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).seccomp as *const _ as usize },
        2864usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(seccomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).parent_exec_id as *const _ as usize },
        2880usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(parent_exec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).self_exec_id as *const _ as usize },
        2888usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(self_exec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).alloc_lock as *const _ as usize },
        2896usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(alloc_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_lock as *const _ as usize },
        2900usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).wake_q as *const _ as usize },
        2904usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_waiters as *const _ as usize },
        2912usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_waiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_top_task as *const _ as usize },
        2928usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_top_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_blocked_on as *const _ as usize },
        2936usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_blocked_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).journal_info as *const _ as usize },
        2944usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(journal_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).bio_list as *const _ as usize },
        2952usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(bio_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).plug as *const _ as usize },
        2960usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(plug)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).reclaim_state as *const _ as usize },
        2968usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(reclaim_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).backing_dev_info as *const _ as usize },
        2976usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(backing_dev_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).io_context as *const _ as usize },
        2984usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(io_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace_message as *const _ as usize },
        2992usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace_message)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).last_siginfo as *const _ as usize },
        3000usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_siginfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ioac as *const _ as usize },
        3008usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ioac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).acct_rss_mem1 as *const _ as usize },
        3064usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_rss_mem1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).acct_vm_mem1 as *const _ as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_vm_mem1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).acct_timexpd as *const _ as usize },
        3080usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_timexpd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mems_allowed as *const _ as usize },
        3088usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mems_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mems_allowed_seq as *const _ as usize },
        3216usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mems_allowed_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).cpuset_mem_spread_rotor as *const _ as usize
        },
        3220usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpuset_mem_spread_rotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).cpuset_slab_spread_rotor as *const _ as usize
        },
        3224usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpuset_slab_spread_rotor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cgroups as *const _ as usize },
        3232usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cgroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).cg_list as *const _ as usize },
        3240usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).closid as *const _ as usize },
        3256usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(closid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rmid as *const _ as usize },
        3260usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rmid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).robust_list as *const _ as usize },
        3264usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(robust_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).compat_robust_list as *const _ as usize },
        3272usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(compat_robust_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_state_list as *const _ as usize },
        3280usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_state_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pi_state_cache as *const _ as usize },
        3296usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_state_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).perf_event_ctxp as *const _ as usize },
        3304usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_ctxp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).perf_event_mutex as *const _ as usize },
        3320usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).perf_event_list as *const _ as usize },
        3352usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).mempolicy as *const _ as usize },
        3368usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mempolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).il_prev as *const _ as usize },
        3376usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(il_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pref_node_fork as *const _ as usize },
        3378usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pref_node_fork)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_scan_seq as *const _ as usize },
        3380usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_scan_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_scan_period as *const _ as usize },
        3384usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_scan_period)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).numa_scan_period_max as *const _ as usize
        },
        3388usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_scan_period_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_preferred_nid as *const _ as usize },
        3392usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_preferred_nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_migrate_retry as *const _ as usize },
        3400usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_migrate_retry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).node_stamp as *const _ as usize },
        3408usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(node_stamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).last_task_numa_placement as *const _ as usize
        },
        3416usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_task_numa_placement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).last_sum_exec_runtime as *const _ as usize
        },
        3424usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_sum_exec_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_work as *const _ as usize },
        3432usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_group as *const _ as usize },
        3448usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).numa_faults as *const _ as usize },
        3456usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_faults)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).total_numa_faults as *const _ as usize },
        3464usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(total_numa_faults)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).numa_faults_locality as *const _ as usize
        },
        3472usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_faults_locality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).numa_pages_migrated as *const _ as usize
        },
        3496usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(numa_pages_migrated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rseq as *const _ as usize },
        3504usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rseq_len as *const _ as usize },
        3512usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rseq_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rseq_sig as *const _ as usize },
        3516usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rseq_sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rseq_event_mask as *const _ as usize },
        3520usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rseq_event_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).tlb_ubc as *const _ as usize },
        3528usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tlb_ubc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).rcu as *const _ as usize },
        4560usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).splice_pipe as *const _ as usize },
        4576usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(splice_pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).task_frag as *const _ as usize },
        4584usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(task_frag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).delays as *const _ as usize },
        4600usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(delays)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nr_dirtied as *const _ as usize },
        4608usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_dirtied)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).nr_dirtied_pause as *const _ as usize },
        4612usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_dirtied_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).dirty_paused_when as *const _ as usize },
        4616usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(dirty_paused_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).timer_slack_ns as *const _ as usize },
        4624usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(timer_slack_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).default_timer_slack_ns as *const _ as usize
        },
        4632usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(default_timer_slack_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).curr_ret_stack as *const _ as usize },
        4640usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(curr_ret_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).curr_ret_depth as *const _ as usize },
        4644usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(curr_ret_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ret_stack as *const _ as usize },
        4648usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ret_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).ftrace_timestamp as *const _ as usize },
        4656usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ftrace_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).trace_overrun as *const _ as usize },
        4664usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(trace_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).tracing_graph_pause as *const _ as usize
        },
        4668usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tracing_graph_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).trace as *const _ as usize },
        4672usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(trace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).trace_recursion as *const _ as usize },
        4680usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(trace_recursion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).memcg_in_oom as *const _ as usize },
        4688usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_in_oom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).memcg_oom_gfp_mask as *const _ as usize },
        4696usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_oom_gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).memcg_oom_order as *const _ as usize },
        4700usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_oom_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<task_struct>())).memcg_nr_pages_over_high as *const _ as usize
        },
        4704usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(memcg_nr_pages_over_high)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).active_memcg as *const _ as usize },
        4712usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(active_memcg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).throttle_queue as *const _ as usize },
        4720usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(throttle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).utask as *const _ as usize },
        4728usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(utask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sequential_io as *const _ as usize },
        4736usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sequential_io)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).sequential_io_avg as *const _ as usize },
        4740usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sequential_io_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).pagefault_disabled as *const _ as usize },
        4744usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pagefault_disabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).oom_reaper_list as *const _ as usize },
        4752usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(oom_reaper_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack_vm_area as *const _ as usize },
        4760usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack_vm_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).stack_refcount as *const _ as usize },
        4768usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).patch_state as *const _ as usize },
        4772usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(patch_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).security as *const _ as usize },
        4776usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<task_struct>())).thread as *const _ as usize },
        4800usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread)
        )
    );
}
impl Default for task_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl task_struct {
    #[inline]
    pub fn sched_reset_on_fork(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_reset_on_fork(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_contributes_to_load(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_contributes_to_load(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_migrated(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_migrated(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_remote_wakeup(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_remote_wakeup(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_execve(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_execve(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_iowait(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_iowait(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restore_sigmask(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restore_sigmask(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_user_fault(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_user_fault(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memcg_kmem_skip_account(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memcg_kmem_skip_account(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_migration(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_migration(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_memdelay(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_memdelay(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sched_reset_on_fork: c_types::c_uint,
        sched_contributes_to_load: c_types::c_uint,
        sched_migrated: c_types::c_uint,
        sched_remote_wakeup: c_types::c_uint,
        in_execve: c_types::c_uint,
        in_iowait: c_types::c_uint,
        restore_sigmask: c_types::c_uint,
        in_user_fault: c_types::c_uint,
        memcg_kmem_skip_account: c_types::c_uint,
        no_cgroup_migration: c_types::c_uint,
        use_memdelay: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 5usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sched_reset_on_fork: u32 = unsafe { ::core::mem::transmute(sched_reset_on_fork) };
            sched_reset_on_fork as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sched_contributes_to_load: u32 =
                unsafe { ::core::mem::transmute(sched_contributes_to_load) };
            sched_contributes_to_load as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sched_migrated: u32 = unsafe { ::core::mem::transmute(sched_migrated) };
            sched_migrated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sched_remote_wakeup: u32 = unsafe { ::core::mem::transmute(sched_remote_wakeup) };
            sched_remote_wakeup as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let in_execve: u32 = unsafe { ::core::mem::transmute(in_execve) };
            in_execve as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let in_iowait: u32 = unsafe { ::core::mem::transmute(in_iowait) };
            in_iowait as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let restore_sigmask: u32 = unsafe { ::core::mem::transmute(restore_sigmask) };
            restore_sigmask as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let in_user_fault: u32 = unsafe { ::core::mem::transmute(in_user_fault) };
            in_user_fault as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let memcg_kmem_skip_account: u32 =
                unsafe { ::core::mem::transmute(memcg_kmem_skip_account) };
            memcg_kmem_skip_account as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let no_cgroup_migration: u32 = unsafe { ::core::mem::transmute(no_cgroup_migration) };
            no_cgroup_migration as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let use_memdelay: u32 = unsafe { ::core::mem::transmute(use_memdelay) };
            use_memdelay as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev {
    pub kobj: kobject,
    pub owner: *mut module,
    pub ops: *const file_operations,
    pub list: list_head,
    pub dev: dev_t,
    pub count: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_cdev() {
    assert_eq!(
        ::core::mem::size_of::<cdev>(),
        104usize,
        concat!("Size of: ", stringify!(cdev))
    );
    assert_eq!(
        ::core::mem::align_of::<cdev>(),
        8usize,
        concat!("Alignment of ", stringify!(cdev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).kobj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).owner as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).ops as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(cdev), "::", stringify!(ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).list as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).dev as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(cdev), "::", stringify!(dev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).count as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(count)
        )
    );
}
impl Default for cdev {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn cdev_init(arg1: *mut cdev, arg2: *const file_operations);
}
extern "C" {
    pub fn cdev_add(arg1: *mut cdev, arg2: dev_t, arg3: c_types::c_uint) -> c_types::c_int;
}
extern "C" {
    pub fn cdev_del(arg1: *mut cdev);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_head {
    pub first: *mut hlist_bl_node,
}
#[test]
fn bindgen_test_layout_hlist_bl_head() {
    assert_eq!(
        ::core::mem::size_of::<hlist_bl_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_bl_head))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_bl_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_bl_head))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_bl_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_head),
            "::",
            stringify!(first)
        )
    );
}
impl Default for hlist_bl_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_node {
    pub next: *mut hlist_bl_node,
    pub pprev: *mut *mut hlist_bl_node,
}
#[test]
fn bindgen_test_layout_hlist_bl_node() {
    assert_eq!(
        ::core::mem::size_of::<hlist_bl_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_bl_node))
    );
    assert_eq!(
        ::core::mem::align_of::<hlist_bl_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_bl_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_bl_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hlist_bl_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_node),
            "::",
            stringify!(pprev)
        )
    );
}
impl Default for hlist_bl_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub lock_count: __u64,
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: c_types::c_int,
}
#[test]
fn bindgen_test_layout_lockref__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lockref__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lockref__bindgen_ty_1__bindgen_ty_1>())).lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lockref__bindgen_ty_1__bindgen_ty_1>())).count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
}
impl Default for lockref__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_lockref__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<lockref__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lockref__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lockref__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lockref__bindgen_ty_1>())).lock_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1),
            "::",
            stringify!(lock_count)
        )
    );
}
impl Default for lockref__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_lockref() {
    assert_eq!(
        ::core::mem::size_of::<lockref>(),
        8usize,
        concat!("Size of: ", stringify!(lockref))
    );
    assert_eq!(
        ::core::mem::align_of::<lockref>(),
        8usize,
        concat!("Alignment of ", stringify!(lockref))
    );
}
impl Default for lockref {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsmount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qstr {
    pub __bindgen_anon_1: qstr__bindgen_ty_1,
    pub name: *const c_types::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qstr__bindgen_ty_1 {
    pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
    pub hash_len: u64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u32,
    pub len: u32,
}
#[test]
fn bindgen_test_layout_qstr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qstr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(qstr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qstr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qstr__bindgen_ty_1__bindgen_ty_1>())).hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<qstr__bindgen_ty_1__bindgen_ty_1>())).len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
}
#[test]
fn bindgen_test_layout_qstr__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<qstr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(qstr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<qstr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(qstr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qstr__bindgen_ty_1>())).hash_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1),
            "::",
            stringify!(hash_len)
        )
    );
}
impl Default for qstr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_qstr() {
    assert_eq!(
        ::core::mem::size_of::<qstr>(),
        16usize,
        concat!("Size of: ", stringify!(qstr))
    );
    assert_eq!(
        ::core::mem::align_of::<qstr>(),
        8usize,
        concat!("Alignment of ", stringify!(qstr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qstr>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr),
            "::",
            stringify!(name)
        )
    );
}
impl Default for qstr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dentry {
    pub d_flags: c_types::c_uint,
    pub d_seq: seqcount_t,
    pub d_hash: hlist_bl_node,
    pub d_parent: *mut dentry,
    pub d_name: qstr,
    pub d_inode: *mut inode,
    pub d_iname: [c_types::c_uchar; 32usize],
    pub d_lockref: lockref,
    pub d_op: *const dentry_operations,
    pub d_sb: *mut super_block,
    pub d_time: c_types::c_ulong,
    pub d_fsdata: *mut c_types::c_void,
    pub __bindgen_anon_1: dentry__bindgen_ty_1,
    pub d_child: list_head,
    pub d_subdirs: list_head,
    pub d_u: dentry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_1 {
    pub d_lru: list_head,
    pub d_wait: *mut wait_queue_head_t,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_dentry__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<dentry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(dentry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_1>())).d_lru as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_1),
            "::",
            stringify!(d_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_1>())).d_wait as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_1),
            "::",
            stringify!(d_wait)
        )
    );
}
impl Default for dentry__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_2 {
    pub d_alias: hlist_node,
    pub d_in_lookup_hash: hlist_bl_node,
    pub d_rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_dentry__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<dentry__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(dentry__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_alias as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_alias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_in_lookup_hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_in_lookup_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_rcu)
        )
    );
}
impl Default for dentry__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_dentry() {
    assert_eq!(
        ::core::mem::size_of::<dentry>(),
        192usize,
        concat!("Size of: ", stringify!(dentry))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_inode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_iname as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_iname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_lockref as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_lockref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_op as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_sb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_time as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_fsdata as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_fsdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_child as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_subdirs as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_subdirs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry>())).d_u as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_u)
        )
    );
}
impl Default for dentry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dentry_operations {
    pub d_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub d_weak_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub d_hash: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> c_types::c_int,
    >,
    pub d_compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dentry,
            arg2: c_types::c_uint,
            arg3: *const c_types::c_char,
            arg4: *const qstr,
        ) -> c_types::c_int,
    >,
    pub d_delete:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> c_types::c_int>,
    pub d_init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> c_types::c_int>,
    pub d_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_prune: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_iput: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
    pub d_dname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut c_types::c_char,
            arg3: c_types::c_int,
        ) -> *mut c_types::c_char,
    >,
    pub d_automount: ::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
    pub d_manage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> c_types::c_int,
    >,
    pub d_real: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *const inode) -> *mut dentry,
    >,
    pub __bindgen_padding_0: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_dentry_operations() {
    assert_eq!(
        ::core::mem::size_of::<dentry_operations>(),
        128usize,
        concat!("Size of: ", stringify!(dentry_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<dentry_operations>(),
        64usize,
        concat!("Alignment of ", stringify!(dentry_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_revalidate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_revalidate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dentry_operations>())).d_weak_revalidate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_weak_revalidate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_compare as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_compare)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_delete as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_init as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_release as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_prune as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_prune)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_iput as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_iput)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_dname as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_dname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_automount as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_automount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_manage as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_manage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_real as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_real)
        )
    );
}
impl Default for dentry_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct path {
    pub mnt: *mut vfsmount,
    pub dentry: *mut dentry,
}
#[test]
fn bindgen_test_layout_path() {
    assert_eq!(
        ::core::mem::size_of::<path>(),
        16usize,
        concat!("Size of: ", stringify!(path))
    );
    assert_eq!(
        ::core::mem::align_of::<path>(),
        8usize,
        concat!("Alignment of ", stringify!(path))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<path>())).mnt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(path), "::", stringify!(mnt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<path>())).dentry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(path),
            "::",
            stringify!(dentry)
        )
    );
}
impl Default for path {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrink_control {
    pub gfp_mask: gfp_t,
    pub nid: c_types::c_int,
    pub nr_to_scan: c_types::c_ulong,
    pub nr_scanned: c_types::c_ulong,
    pub memcg: *mut mem_cgroup,
}
#[test]
fn bindgen_test_layout_shrink_control() {
    assert_eq!(
        ::core::mem::size_of::<shrink_control>(),
        32usize,
        concat!("Size of: ", stringify!(shrink_control))
    );
    assert_eq!(
        ::core::mem::align_of::<shrink_control>(),
        8usize,
        concat!("Alignment of ", stringify!(shrink_control))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).gfp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).nid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).nr_to_scan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nr_to_scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).nr_scanned as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nr_scanned)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrink_control>())).memcg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(memcg)
        )
    );
}
impl Default for shrink_control {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrinker {
    pub count_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> c_types::c_ulong,
    >,
    pub scan_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> c_types::c_ulong,
    >,
    pub batch: c_types::c_long,
    pub seeks: c_types::c_int,
    pub flags: c_types::c_uint,
    pub list: list_head,
    pub id: c_types::c_int,
    pub nr_deferred: *mut atomic_long_t,
}
#[test]
fn bindgen_test_layout_shrinker() {
    assert_eq!(
        ::core::mem::size_of::<shrinker>(),
        64usize,
        concat!("Size of: ", stringify!(shrinker))
    );
    assert_eq!(
        ::core::mem::align_of::<shrinker>(),
        8usize,
        concat!("Alignment of ", stringify!(shrinker))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).count_objects as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(count_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).scan_objects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(scan_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).batch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).seeks as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(seeks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<shrinker>())).nr_deferred as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(nr_deferred)
        )
    );
}
impl Default for shrinker {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru_one {
    pub list: list_head,
    pub nr_items: c_types::c_long,
}
#[test]
fn bindgen_test_layout_list_lru_one() {
    assert_eq!(
        ::core::mem::size_of::<list_lru_one>(),
        24usize,
        concat!("Size of: ", stringify!(list_lru_one))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru_one>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru_one))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_one>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_one),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_one>())).nr_items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_one),
            "::",
            stringify!(nr_items)
        )
    );
}
impl Default for list_lru_one {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct list_lru_memcg {
    pub rcu: callback_head,
    pub lru: __IncompleteArrayField<*mut list_lru_one>,
}
#[test]
fn bindgen_test_layout_list_lru_memcg() {
    assert_eq!(
        ::core::mem::size_of::<list_lru_memcg>(),
        16usize,
        concat!("Size of: ", stringify!(list_lru_memcg))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru_memcg>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru_memcg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_memcg>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_memcg),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_memcg>())).lru as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_memcg),
            "::",
            stringify!(lru)
        )
    );
}
impl Default for list_lru_memcg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct list_lru_node {
    pub lock: spinlock_t,
    pub lru: list_lru_one,
    pub memcg_lrus: *mut list_lru_memcg,
    pub nr_items: c_types::c_long,
    pub __bindgen_padding_0: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_list_lru_node() {
    assert_eq!(
        ::core::mem::size_of::<list_lru_node>(),
        64usize,
        concat!("Size of: ", stringify!(list_lru_node))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru_node>(),
        64usize,
        concat!("Alignment of ", stringify!(list_lru_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).lru as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).memcg_lrus as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(memcg_lrus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru_node>())).nr_items as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(nr_items)
        )
    );
}
impl Default for list_lru_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru {
    pub node: *mut list_lru_node,
    pub list: list_head,
    pub shrinker_id: c_types::c_int,
    pub memcg_aware: bool_,
}
#[test]
fn bindgen_test_layout_list_lru() {
    assert_eq!(
        ::core::mem::size_of::<list_lru>(),
        32usize,
        concat!("Size of: ", stringify!(list_lru))
    );
    assert_eq!(
        ::core::mem::align_of::<list_lru>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru>())).shrinker_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(shrinker_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_lru>())).memcg_aware as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(memcg_aware)
        )
    );
}
impl Default for list_lru {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct arch_uprobe_task {
    pub saved_scratch_register: c_types::c_ulong,
    pub saved_trap_nr: c_types::c_uint,
    pub saved_tf: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_arch_uprobe_task() {
    assert_eq!(
        ::core::mem::size_of::<arch_uprobe_task>(),
        16usize,
        concat!("Size of: ", stringify!(arch_uprobe_task))
    );
    assert_eq!(
        ::core::mem::align_of::<arch_uprobe_task>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_uprobe_task))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arch_uprobe_task>())).saved_scratch_register as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_scratch_register)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arch_uprobe_task>())).saved_trap_nr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_trap_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arch_uprobe_task>())).saved_tf as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_tf)
        )
    );
}
pub const uprobe_task_state_UTASK_RUNNING: uprobe_task_state = 0;
pub const uprobe_task_state_UTASK_SSTEP: uprobe_task_state = 1;
pub const uprobe_task_state_UTASK_SSTEP_ACK: uprobe_task_state = 2;
pub const uprobe_task_state_UTASK_SSTEP_TRAPPED: uprobe_task_state = 3;
pub type uprobe_task_state = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_task {
    pub state: uprobe_task_state,
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1,
    pub active_uprobe: *mut uprobe,
    pub xol_vaddr: c_types::c_ulong,
    pub return_instances: *mut return_instance,
    pub depth: c_types::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uprobe_task__bindgen_ty_1 {
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: uprobe_task__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_1 {
    pub autask: arch_uprobe_task,
    pub vaddr: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_1>())).autask as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(autask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_1>())).vaddr as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(vaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    pub dup_xol_work: callback_head,
    pub dup_xol_addr: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_2>())).dup_xol_work
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dup_xol_work)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_2>())).dup_xol_addr
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dup_xol_addr)
        )
    );
}
impl Default for uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(uprobe_task__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobe_task__bindgen_ty_1))
    );
}
impl Default for uprobe_task__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_uprobe_task() {
    assert_eq!(
        ::core::mem::size_of::<uprobe_task>(),
        64usize,
        concat!("Size of: ", stringify!(uprobe_task))
    );
    assert_eq!(
        ::core::mem::align_of::<uprobe_task>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobe_task))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).active_uprobe as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(active_uprobe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).xol_vaddr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(xol_vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).return_instances as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(return_instances)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobe_task>())).depth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(depth)
        )
    );
}
impl Default for uprobe_task {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct return_instance {
    pub uprobe: *mut uprobe,
    pub func: c_types::c_ulong,
    pub stack: c_types::c_ulong,
    pub orig_ret_vaddr: c_types::c_ulong,
    pub chained: bool_,
    pub next: *mut return_instance,
}
#[test]
fn bindgen_test_layout_return_instance() {
    assert_eq!(
        ::core::mem::size_of::<return_instance>(),
        48usize,
        concat!("Size of: ", stringify!(return_instance))
    );
    assert_eq!(
        ::core::mem::align_of::<return_instance>(),
        8usize,
        concat!("Alignment of ", stringify!(return_instance))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).uprobe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(uprobe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).orig_ret_vaddr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(orig_ret_vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).chained as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(chained)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<return_instance>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(next)
        )
    );
}
impl Default for return_instance {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xol_area {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobes_state {
    pub xol_area: *mut xol_area,
}
#[test]
fn bindgen_test_layout_uprobes_state() {
    assert_eq!(
        ::core::mem::size_of::<uprobes_state>(),
        8usize,
        concat!("Size of: ", stringify!(uprobes_state))
    );
    assert_eq!(
        ::core::mem::align_of::<uprobes_state>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobes_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uprobes_state>())).xol_area as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobes_state),
            "::",
            stringify!(xol_area)
        )
    );
}
impl Default for uprobes_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmm {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct page {
    pub flags: c_types::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_2,
    pub _refcount: atomic_t,
    pub mem_cgroup: *mut mem_cgroup,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: page__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: page__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: page__bindgen_ty_1__bindgen_ty_6,
    pub callback_head: callback_head,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " @lru: Pageout list, eg. active_list protected by"]
    #[doc = " zone_lru_lock.  Sometimes used as a generic list"]
    #[doc = " by the page owner."]
    pub lru: list_head,
    pub mapping: *mut address_space,
    pub index: c_types::c_ulong,
    #[doc = " @private: Mapping-private opaque data."]
    #[doc = " Usually used for buffer_heads if PagePrivate."]
    #[doc = " Used for swp_entry_t if PageSwapCache."]
    #[doc = " Indicates order in the buddy system if PageBuddy."]
    pub private: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).lru as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lru)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).mapping as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).index as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).private as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(private)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub slab_cache: *mut kmem_cache,
    pub freelist: *mut c_types::c_void,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub slab_list: list_head,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut page,
    pub pages: c_types::c_int,
    pub pobjects: c_types::c_int,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(
            )))
            .next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(
            )))
            .pages as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(
            )))
            .pobjects as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pobjects)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>())).slab_list
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(slab_list)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    pub s_mem: *mut c_types::c_void,
    pub counters: c_types::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn inuse(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_inuse(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn objects(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_objects(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inuse: c_types::c_uint,
        objects: c_types::c_uint,
        frozen: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let inuse: u32 = unsafe { ::core::mem::transmute(inuse) };
            inuse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let objects: u32 = unsafe { ::core::mem::transmute(objects) };
            objects as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>())).s_mem
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(s_mem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>())).counters
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(counters)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_2>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2>())).slab_cache as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(slab_cache)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2>())).freelist as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(freelist)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3 {
    pub compound_head: c_types::c_ulong,
    pub compound_dtor: c_types::c_uchar,
    pub compound_order: c_types::c_uchar,
    pub compound_mapcount: atomic_t,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).compound_head as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(compound_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).compound_dtor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(compound_dtor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).compound_order as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(compound_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).compound_mapcount
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(compound_mapcount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_4 {
    pub _compound_pad_1: c_types::c_ulong,
    pub _compound_pad_2: c_types::c_ulong,
    pub deferred_list: list_head,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>()))._compound_pad_1
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_compound_pad_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>()))._compound_pad_2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_compound_pad_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>())).deferred_list as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(deferred_list)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_5 {
    pub _pt_pad_1: c_types::c_ulong,
    pub pmd_huge_pte: pgtable_t,
    pub _pt_pad_2: c_types::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    pub ptl: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub pt_mm: *mut mm_struct,
    pub pt_frag_refcount: atomic_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>())).pt_mm
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(pt_mm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))
                .pt_frag_refcount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(pt_frag_refcount)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_5>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>()))._pt_pad_1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_pt_pad_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>())).pmd_huge_pte as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(pmd_huge_pte)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>()))._pt_pad_2 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_pt_pad_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>())).ptl as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(ptl)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_6 {
    #[doc = " @pgmap: Points to the hosting device page map."]
    pub pgmap: *mut dev_pagemap,
    pub hmm_data: c_types::c_ulong,
    pub _zd_pad_1: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_6>(),
        24usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_6>())).pgmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(pgmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_6>())).hmm_data as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(hmm_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_6>()))._zd_pad_1 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(_zd_pad_1)
        )
    );
}
impl Default for page__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(page__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<page__bindgen_ty_1>())).callback_head as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1),
            "::",
            stringify!(callback_head)
        )
    );
}
impl Default for page__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_2 {
    pub _mapcount: atomic_t,
    pub page_type: c_types::c_uint,
    pub active: c_types::c_uint,
    pub units: c_types::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<page__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<page__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(page__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_2>()))._mapcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(_mapcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_2>())).page_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(page_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_2>())).active as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page__bindgen_ty_2>())).units as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(units)
        )
    );
}
impl Default for page__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_page() {
    assert_eq!(
        ::core::mem::size_of::<page>(),
        64usize,
        concat!("Size of: ", stringify!(page))
    );
    assert_eq!(
        ::core::mem::align_of::<page>(),
        16usize,
        concat!("Alignment of ", stringify!(page))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page>()))._refcount as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(page),
            "::",
            stringify!(_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<page>())).mem_cgroup as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(page),
            "::",
            stringify!(mem_cgroup)
        )
    );
}
impl Default for page {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_userfaultfd_ctx {
    pub ctx: *mut userfaultfd_ctx,
}
#[test]
fn bindgen_test_layout_vm_userfaultfd_ctx() {
    assert_eq!(
        ::core::mem::size_of::<vm_userfaultfd_ctx>(),
        8usize,
        concat!("Size of: ", stringify!(vm_userfaultfd_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_userfaultfd_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_userfaultfd_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_userfaultfd_ctx>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_userfaultfd_ctx),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for vm_userfaultfd_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct {
    pub vm_start: c_types::c_ulong,
    pub vm_end: c_types::c_ulong,
    pub vm_next: *mut vm_area_struct,
    pub vm_prev: *mut vm_area_struct,
    pub vm_rb: rb_node,
    pub rb_subtree_gap: c_types::c_ulong,
    pub vm_mm: *mut mm_struct,
    pub vm_page_prot: pgprot_t,
    pub vm_flags: c_types::c_ulong,
    pub shared: vm_area_struct__bindgen_ty_1,
    pub anon_vma_chain: list_head,
    pub anon_vma: *mut anon_vma,
    pub vm_ops: *const vm_operations_struct,
    pub vm_pgoff: c_types::c_ulong,
    pub vm_file: *mut file,
    pub vm_private_data: *mut c_types::c_void,
    pub swap_readahead_info: atomic_long_t,
    pub vm_policy: *mut mempolicy,
    pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_1 {
    pub rb: rb_node,
    pub rb_subtree_last: c_types::c_ulong,
}
#[test]
fn bindgen_test_layout_vm_area_struct__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<vm_area_struct__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(vm_area_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_area_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_area_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_1>())).rb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct__bindgen_ty_1),
            "::",
            stringify!(rb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_1>())).rb_subtree_last as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct__bindgen_ty_1),
            "::",
            stringify!(rb_subtree_last)
        )
    );
}
impl Default for vm_area_struct__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_vm_area_struct() {
    assert_eq!(
        ::core::mem::size_of::<vm_area_struct>(),
        200usize,
        concat!("Size of: ", stringify!(vm_area_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<vm_area_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_area_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_rb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_rb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).rb_subtree_gap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(rb_subtree_gap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_mm as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_page_prot as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_page_prot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).shared as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).anon_vma_chain as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(anon_vma_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).anon_vma as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(anon_vma)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_ops as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_pgoff as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_pgoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_file as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_private_data as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_private_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct>())).swap_readahead_info as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(swap_readahead_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_policy as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_policy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vm_area_struct>())).vm_userfaultfd_ctx as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_userfaultfd_ctx)
        )
    );
}
impl Default for vm_area_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_thread {
    pub task: *mut task_struct,
    pub next: *mut core_thread,
}
#[test]
fn bindgen_test_layout_core_thread() {
    assert_eq!(
        ::core::mem::size_of::<core_thread>(),
        16usize,
        concat!("Size of: ", stringify!(core_thread))
    );
    assert_eq!(
        ::core::mem::align_of::<core_thread>(),
        8usize,
        concat!("Alignment of ", stringify!(core_thread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_thread>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(core_thread),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_thread>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(core_thread),
            "::",
            stringify!(next)
        )
    );
}
impl Default for core_thread {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_state {
    pub nr_threads: atomic_t,
    pub dumper: core_thread,
    pub startup: completion,
}
#[test]
fn bindgen_test_layout_core_state() {
    assert_eq!(
        ::core::mem::size_of::<core_state>(),
        56usize,
        concat!("Size of: ", stringify!(core_state))
    );
    assert_eq!(
        ::core::mem::align_of::<core_state>(),
        8usize,
        concat!("Alignment of ", stringify!(core_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_state>())).nr_threads as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(nr_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_state>())).dumper as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(dumper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<core_state>())).startup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(startup)
        )
    );
}
impl Default for core_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kioctx_table {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct mm_struct {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1,
    pub cpu_bitmap: __IncompleteArrayField<c_types::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1 {
    pub mmap: *mut vm_area_struct,
    pub mm_rb: rb_root,
    pub vmacache_seqnum: u64,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            filp: *mut file,
            addr: c_types::c_ulong,
            len: c_types::c_ulong,
            pgoff: c_types::c_ulong,
            flags: c_types::c_ulong,
        ) -> c_types::c_ulong,
    >,
    pub mmap_base: c_types::c_ulong,
    pub mmap_legacy_base: c_types::c_ulong,
    pub mmap_compat_base: c_types::c_ulong,
    pub mmap_compat_legacy_base: c_types::c_ulong,
    pub task_size: c_types::c_ulong,
    pub highest_vm_end: c_types::c_ulong,
    pub pgd: *mut pgd_t,
    #[doc = " @mm_users: The number of users including userspace."]
    #[doc = ""]
    #[doc = " Use mmget()/mmget_not_zero()/mmput() to modify. When this"]
    #[doc = " drops to 0 (i.e. when the task exits and there are no other"]
    #[doc = " temporary reference holders), we also release a reference on"]
    #[doc = " @mm_count (which may then free the &struct mm_struct if"]
    #[doc = " @mm_count also drops to 0)."]
    pub mm_users: atomic_t,
    #[doc = " @mm_count: The number of references to &struct mm_struct"]
    #[doc = " (@mm_users count as 1)."]
    #[doc = ""]
    #[doc = " Use mmgrab()/mmdrop() to modify. When this drops to 0, the"]
    #[doc = " &struct mm_struct is freed."]
    pub mm_count: atomic_t,
    pub pgtables_bytes: atomic_long_t,
    pub map_count: c_types::c_int,
    pub page_table_lock: spinlock_t,
    pub mmap_sem: rw_semaphore,
    pub mmlist: list_head,
    pub hiwater_rss: c_types::c_ulong,
    pub hiwater_vm: c_types::c_ulong,
    pub total_vm: c_types::c_ulong,
    pub locked_vm: c_types::c_ulong,
    pub pinned_vm: c_types::c_ulong,
    pub data_vm: c_types::c_ulong,
    pub exec_vm: c_types::c_ulong,
    pub stack_vm: c_types::c_ulong,
    pub def_flags: c_types::c_ulong,
    pub arg_lock: spinlock_t,
    pub start_code: c_types::c_ulong,
    pub end_code: c_types::c_ulong,
    pub start_data: c_types::c_ulong,
    pub end_data: c_types::c_ulong,
    pub start_brk: c_types::c_ulong,
    pub brk: c_types::c_ulong,
    pub start_stack: c_types::c_ulong,
    pub arg_start: c_types::c_ulong,
    pub arg_end: c_types::c_ulong,
    pub env_start: c_types::c_ulong,
    pub env_end: c_types::c_ulong,
    pub saved_auxv: [c_types::c_ulong; 46usize],
    pub rss_stat: mm_rss_stat,
    pub binfmt: *mut linux_binfmt,
    pub context: mm_context_t,
    pub flags: c_types::c_ulong,
    pub core_state: *mut core_state,
    pub membarrier_state: atomic_t,
    pub ioctx_lock: spinlock_t,
    pub ioctx_table: *mut kioctx_table,
    pub owner: *mut task_struct,
    pub user_ns: *mut user_namespace,
    pub exe_file: *mut file,
    pub mmu_notifier_mm: *mut mmu_notifier_mm,
    pub numa_next_scan: c_types::c_ulong,
    pub numa_scan_offset: c_types::c_ulong,
    pub numa_scan_seq: c_types::c_int,
    pub tlb_flush_pending: atomic_t,
    pub tlb_flush_batched: bool_,
    pub uprobes_state: uprobes_state,
    pub hugetlb_usage: atomic_long_t,
    pub async_put_work: work_struct,
    pub hmm: *mut hmm,
}
#[test]
fn bindgen_test_layout_mm_struct__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<mm_struct__bindgen_ty_1>(),
        1032usize,
        concat!("Size of: ", stringify!(mm_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mm_rb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mm_rb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).vmacache_seqnum as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(vmacache_seqnum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).get_unmapped_area as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(get_unmapped_area)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_base as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_legacy_base as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_legacy_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_compat_base as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_compat_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_compat_legacy_base as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_compat_legacy_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).task_size as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(task_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).highest_vm_end as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(highest_vm_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).pgd as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(pgd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mm_users as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mm_users)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mm_count as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mm_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).pgtables_bytes as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(pgtables_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).map_count as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(map_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).page_table_lock as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(page_table_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_sem as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmlist as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmlist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).hiwater_rss as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(hiwater_rss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).hiwater_vm as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(hiwater_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).total_vm as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(total_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).locked_vm as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(locked_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).pinned_vm as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(pinned_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).data_vm as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(data_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).exec_vm as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(exec_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).stack_vm as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(stack_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).def_flags as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(def_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).arg_lock as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(arg_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_code as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).end_code as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(end_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_data as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).end_data as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(end_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_brk as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_brk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).brk as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(brk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_stack as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_stack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).arg_start as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(arg_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).arg_end as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(arg_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).env_start as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(env_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).env_end as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(env_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).saved_auxv as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(saved_auxv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).rss_stat as *const _ as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(rss_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).binfmt as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(binfmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).context as *const _ as usize
        },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).flags as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).core_state as *const _ as usize
        },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(core_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).membarrier_state as *const _
                as usize
        },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(membarrier_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).ioctx_lock as *const _ as usize
        },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(ioctx_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).ioctx_table as *const _ as usize
        },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(ioctx_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).owner as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).user_ns as *const _ as usize
        },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(user_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).exe_file as *const _ as usize
        },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(exe_file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmu_notifier_mm as *const _
                as usize
        },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmu_notifier_mm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).numa_next_scan as *const _ as usize
        },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(numa_next_scan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).numa_scan_offset as *const _
                as usize
        },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(numa_scan_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).numa_scan_seq as *const _ as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(numa_scan_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).tlb_flush_pending as *const _
                as usize
        },
        964usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(tlb_flush_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).tlb_flush_batched as *const _
                as usize
        },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(tlb_flush_batched)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).uprobes_state as *const _ as usize
        },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(uprobes_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).hugetlb_usage as *const _ as usize
        },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(hugetlb_usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).async_put_work as *const _ as usize
        },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(async_put_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).hmm as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(hmm)
        )
    );
}
impl Default for mm_struct__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_mm_struct() {
    assert_eq!(
        ::core::mem::size_of::<mm_struct>(),
        1032usize,
        concat!("Size of: ", stringify!(mm_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mm_struct>())).cpu_bitmap as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(cpu_bitmap)
        )
    );
}
impl Default for mm_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fiemap_extent {
    pub fe_logical: __u64,
    pub fe_physical: __u64,
    pub fe_length: __u64,
    pub fe_reserved64: [__u64; 2usize],
    pub fe_flags: __u32,
    pub fe_reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_fiemap_extent() {
    assert_eq!(
        ::core::mem::size_of::<fiemap_extent>(),
        56usize,
        concat!("Size of: ", stringify!(fiemap_extent))
    );
    assert_eq!(
        ::core::mem::align_of::<fiemap_extent>(),
        8usize,
        concat!("Alignment of ", stringify!(fiemap_extent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_logical as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_logical)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_physical as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_physical)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_reserved64 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_reserved64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent>())).fe_reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent),
            "::",
            stringify!(fe_reserved)
        )
    );
}
pub const migrate_mode_MIGRATE_ASYNC: migrate_mode = 0;
pub const migrate_mode_MIGRATE_SYNC_LIGHT: migrate_mode = 1;
pub const migrate_mode_MIGRATE_SYNC: migrate_mode = 2;
pub const migrate_mode_MIGRATE_SYNC_NO_COPY: migrate_mode = 3;
pub type migrate_mode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcuwait {
    pub task: *mut task_struct,
}
#[test]
fn bindgen_test_layout_rcuwait() {
    assert_eq!(
        ::core::mem::size_of::<rcuwait>(),
        8usize,
        concat!("Size of: ", stringify!(rcuwait))
    );
    assert_eq!(
        ::core::mem::align_of::<rcuwait>(),
        8usize,
        concat!("Alignment of ", stringify!(rcuwait))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcuwait>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcuwait),
            "::",
            stringify!(task)
        )
    );
}
impl Default for rcuwait {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const rcu_sync_type_RCU_SYNC: rcu_sync_type = 0;
pub const rcu_sync_type_RCU_SCHED_SYNC: rcu_sync_type = 1;
pub const rcu_sync_type_RCU_BH_SYNC: rcu_sync_type = 2;
pub type rcu_sync_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_sync {
    pub gp_state: c_types::c_int,
    pub gp_count: c_types::c_int,
    pub gp_wait: wait_queue_head_t,
    pub cb_state: c_types::c_int,
    pub cb_head: callback_head,
    pub gp_type: rcu_sync_type,
}
#[test]
fn bindgen_test_layout_rcu_sync() {
    assert_eq!(
        ::core::mem::size_of::<rcu_sync>(),
        64usize,
        concat!("Size of: ", stringify!(rcu_sync))
    );
    assert_eq!(
        ::core::mem::align_of::<rcu_sync>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_sync))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).cb_state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(cb_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).cb_head as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(cb_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_type as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_type)
        )
    );
}
impl Default for rcu_sync {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_rw_semaphore {
    pub rss: rcu_sync,
    pub read_count: *mut c_types::c_uint,
    pub rw_sem: rw_semaphore,
    pub writer: rcuwait,
    pub readers_block: c_types::c_int,
}
#[test]
fn bindgen_test_layout_percpu_rw_semaphore() {
    assert_eq!(
        ::core::mem::size_of::<percpu_rw_semaphore>(),
        128usize,
        concat!("Size of: ", stringify!(percpu_rw_semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<percpu_rw_semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(percpu_rw_semaphore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).rss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(rss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).read_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(read_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).rw_sem as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(rw_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).writer as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<percpu_rw_semaphore>())).readers_block as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(readers_block)
        )
    );
}
impl Default for percpu_rw_semaphore {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_call {
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
    pub arg: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_delayed_call() {
    assert_eq!(
        ::core::mem::size_of::<delayed_call>(),
        16usize,
        concat!("Size of: ", stringify!(delayed_call))
    );
    assert_eq!(
        ::core::mem::align_of::<delayed_call>(),
        8usize,
        concat!("Alignment of ", stringify!(delayed_call))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_call>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_call),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<delayed_call>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_call),
            "::",
            stringify!(arg)
        )
    );
}
impl Default for delayed_call {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uuid_t {
    pub b: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_uuid_t() {
    assert_eq!(
        ::core::mem::size_of::<uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(uuid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uuid_t>())).b as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uuid_t), "::", stringify!(b))
    );
}
pub type errseq_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_cq {
    pub q: *mut request_queue,
    pub ioc: *mut io_context,
    pub __bindgen_anon_1: io_cq__bindgen_ty_1,
    pub __bindgen_anon_2: io_cq__bindgen_ty_2,
    pub flags: c_types::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_1 {
    pub q_node: list_head,
    pub __rcu_icq_cache: *mut kmem_cache,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_io_cq__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<io_cq__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(io_cq__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<io_cq__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq__bindgen_ty_1>())).q_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_1),
            "::",
            stringify!(q_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<io_cq__bindgen_ty_1>())).__rcu_icq_cache as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_1),
            "::",
            stringify!(__rcu_icq_cache)
        )
    );
}
impl Default for io_cq__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_2 {
    pub ioc_node: hlist_node,
    pub __rcu_head: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_io_cq__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<io_cq__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(io_cq__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<io_cq__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq__bindgen_ty_2>())).ioc_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_2),
            "::",
            stringify!(ioc_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq__bindgen_ty_2>())).__rcu_head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_2),
            "::",
            stringify!(__rcu_head)
        )
    );
}
impl Default for io_cq__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_io_cq() {
    assert_eq!(
        ::core::mem::size_of::<io_cq>(),
        56usize,
        concat!("Size of: ", stringify!(io_cq))
    );
    assert_eq!(
        ::core::mem::align_of::<io_cq>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq>())).q as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(io_cq), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq>())).ioc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq),
            "::",
            stringify!(ioc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_cq>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for io_cq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_context {
    pub refcount: atomic_long_t,
    pub active_ref: atomic_t,
    pub nr_tasks: atomic_t,
    pub lock: spinlock_t,
    pub ioprio: c_types::c_ushort,
    pub nr_batch_requests: c_types::c_int,
    pub last_waited: c_types::c_ulong,
    pub icq_tree: radix_tree_root,
    pub icq_hint: *mut io_cq,
    pub icq_list: hlist_head,
    pub release_work: work_struct,
}
#[test]
fn bindgen_test_layout_io_context() {
    assert_eq!(
        ::core::mem::size_of::<io_context>(),
        104usize,
        concat!("Size of: ", stringify!(io_context))
    );
    assert_eq!(
        ::core::mem::align_of::<io_context>(),
        8usize,
        concat!("Alignment of ", stringify!(io_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).active_ref as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(active_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).nr_tasks as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(nr_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).ioprio as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(ioprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).nr_batch_requests as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(nr_batch_requests)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).last_waited as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(last_waited)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).icq_tree as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(icq_tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).icq_hint as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(icq_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).icq_list as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(icq_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_context>())).release_work as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(release_work)
        )
    );
}
impl Default for io_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bdi_writeback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct export_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct poll_table_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstatfs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cred {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swap_info_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iov_iter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iattr {
    pub ia_valid: c_types::c_uint,
    pub ia_mode: umode_t,
    pub ia_uid: kuid_t,
    pub ia_gid: kgid_t,
    pub ia_size: loff_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub ia_file: *mut file,
}
#[test]
fn bindgen_test_layout_iattr() {
    assert_eq!(
        ::core::mem::size_of::<iattr>(),
        80usize,
        concat!("Size of: ", stringify!(iattr))
    );
    assert_eq!(
        ::core::mem::align_of::<iattr>(),
        8usize,
        concat!("Alignment of ", stringify!(iattr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_valid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_uid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_gid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_atime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_mtime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_ctime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iattr>())).ia_file as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_file)
        )
    );
}
impl Default for iattr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type projid_t = __kernel_uid32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kprojid_t {
    pub val: projid_t,
}
#[test]
fn bindgen_test_layout_kprojid_t() {
    assert_eq!(
        ::core::mem::size_of::<kprojid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kprojid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<kprojid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kprojid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kprojid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kprojid_t),
            "::",
            stringify!(val)
        )
    );
}
pub const quota_type_USRQUOTA: quota_type = 0;
pub const quota_type_GRPQUOTA: quota_type = 1;
pub const quota_type_PRJQUOTA: quota_type = 2;
pub type quota_type = u32;
pub type qsize_t = c_types::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kqid {
    pub __bindgen_anon_1: kqid__bindgen_ty_1,
    pub type_: quota_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kqid__bindgen_ty_1 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub projid: kprojid_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_kqid__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kqid__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(kqid__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kqid__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(kqid__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).uid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).gid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).projid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(projid)
        )
    );
}
impl Default for kqid__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_kqid() {
    assert_eq!(
        ::core::mem::size_of::<kqid>(),
        8usize,
        concat!("Size of: ", stringify!(kqid))
    );
    assert_eq!(
        ::core::mem::align_of::<kqid>(),
        4usize,
        concat!("Alignment of ", stringify!(kqid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kqid>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for kqid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mem_dqblk {
    pub dqb_bhardlimit: qsize_t,
    pub dqb_bsoftlimit: qsize_t,
    pub dqb_curspace: qsize_t,
    pub dqb_rsvspace: qsize_t,
    pub dqb_ihardlimit: qsize_t,
    pub dqb_isoftlimit: qsize_t,
    pub dqb_curinodes: qsize_t,
    pub dqb_btime: time64_t,
    pub dqb_itime: time64_t,
}
#[test]
fn bindgen_test_layout_mem_dqblk() {
    assert_eq!(
        ::core::mem::size_of::<mem_dqblk>(),
        72usize,
        concat!("Size of: ", stringify!(mem_dqblk))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_dqblk>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_dqblk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_bhardlimit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_bhardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_bsoftlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_bsoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_curspace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_curspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_rsvspace as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_rsvspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_ihardlimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_ihardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_isoftlimit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_isoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_curinodes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_curinodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_btime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_itime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_itime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_dqinfo {
    pub dqi_format: *mut quota_format_type,
    pub dqi_fmt_id: c_types::c_int,
    pub dqi_dirty_list: list_head,
    pub dqi_flags: c_types::c_ulong,
    pub dqi_bgrace: c_types::c_uint,
    pub dqi_igrace: c_types::c_uint,
    pub dqi_max_spc_limit: qsize_t,
    pub dqi_max_ino_limit: qsize_t,
    pub dqi_priv: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_mem_dqinfo() {
    assert_eq!(
        ::core::mem::size_of::<mem_dqinfo>(),
        72usize,
        concat!("Size of: ", stringify!(mem_dqinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<mem_dqinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_dqinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_fmt_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_fmt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_dirty_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_dirty_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_bgrace as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_bgrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_igrace as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_igrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_max_spc_limit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_max_spc_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_max_ino_limit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_max_ino_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_priv as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_priv)
        )
    );
}
impl Default for mem_dqinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dquot {
    pub dq_hash: hlist_node,
    pub dq_inuse: list_head,
    pub dq_free: list_head,
    pub dq_dirty: list_head,
    pub dq_lock: mutex,
    pub dq_dqb_lock: spinlock_t,
    pub dq_count: atomic_t,
    pub dq_sb: *mut super_block,
    pub dq_id: kqid,
    pub dq_off: loff_t,
    pub dq_flags: c_types::c_ulong,
    pub dq_dqb: mem_dqblk,
}
#[test]
fn bindgen_test_layout_dquot() {
    assert_eq!(
        ::core::mem::size_of::<dquot>(),
        208usize,
        concat!("Size of: ", stringify!(dquot))
    );
    assert_eq!(
        ::core::mem::align_of::<dquot>(),
        8usize,
        concat!("Alignment of ", stringify!(dquot))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_inuse as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_inuse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_dirty as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_dqb_lock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dqb_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_count as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_sb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_id as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_off as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_flags as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot>())).dq_dqb as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dqb)
        )
    );
}
impl Default for dquot {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct quota_format_ops {
    pub check_quota_file: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub read_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub write_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub free_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: c_types::c_int) -> c_types::c_int,
    >,
    pub read_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> c_types::c_int>,
    pub commit_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> c_types::c_int>,
    pub release_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> c_types::c_int>,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_quota_format_ops() {
    assert_eq!(
        ::core::mem::size_of::<quota_format_ops>(),
        64usize,
        concat!("Size of: ", stringify!(quota_format_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<quota_format_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_format_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).check_quota_file as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(check_quota_file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).read_file_info as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(read_file_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).write_file_info as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(write_file_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<quota_format_ops>())).free_file_info as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(free_file_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).read_dqblk as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(read_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).commit_dqblk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(commit_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).release_dqblk as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(release_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_ops>())).get_next_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(get_next_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dquot_operations {
    pub write_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub alloc_dquot: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> *mut dquot,
    >,
    pub destroy_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
    pub acquire_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub release_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub mark_dirty:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> c_types::c_int>,
    pub write_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub get_reserved_space:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
    pub get_projid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> c_types::c_int,
    >,
    pub get_inode_usage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> c_types::c_int,
    >,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_dquot_operations() {
    assert_eq!(
        ::core::mem::size_of::<dquot_operations>(),
        88usize,
        concat!("Size of: ", stringify!(dquot_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<dquot_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(dquot_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).write_dquot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(write_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).alloc_dquot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(alloc_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).destroy_dquot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(destroy_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).acquire_dquot as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(acquire_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).release_dquot as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(release_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).mark_dirty as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(mark_dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).write_info as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(write_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dquot_operations>())).get_reserved_space as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_reserved_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).get_projid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_projid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<dquot_operations>())).get_inode_usage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_inode_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dquot_operations>())).get_next_id as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_next_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_dqblk {
    pub d_fieldmask: c_types::c_int,
    pub d_spc_hardlimit: u64,
    pub d_spc_softlimit: u64,
    pub d_ino_hardlimit: u64,
    pub d_ino_softlimit: u64,
    pub d_space: u64,
    pub d_ino_count: u64,
    pub d_ino_timer: s64,
    pub d_spc_timer: s64,
    pub d_ino_warns: c_types::c_int,
    pub d_spc_warns: c_types::c_int,
    pub d_rt_spc_hardlimit: u64,
    pub d_rt_spc_softlimit: u64,
    pub d_rt_space: u64,
    pub d_rt_spc_timer: s64,
    pub d_rt_spc_warns: c_types::c_int,
}
#[test]
fn bindgen_test_layout_qc_dqblk() {
    assert_eq!(
        ::core::mem::size_of::<qc_dqblk>(),
        120usize,
        concat!("Size of: ", stringify!(qc_dqblk))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_dqblk>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_dqblk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_fieldmask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_fieldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_hardlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_softlimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_hardlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_softlimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_space as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_timer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_timer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_warns as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_warns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_warns as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_warns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_hardlimit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_softlimit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_space as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_timer as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_warns as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_warns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_type_state {
    pub flags: c_types::c_uint,
    pub spc_timelimit: c_types::c_uint,
    pub ino_timelimit: c_types::c_uint,
    pub rt_spc_timelimit: c_types::c_uint,
    pub spc_warnlimit: c_types::c_uint,
    pub ino_warnlimit: c_types::c_uint,
    pub rt_spc_warnlimit: c_types::c_uint,
    pub ino: c_types::c_ulonglong,
    pub blocks: blkcnt_t,
    pub nextents: blkcnt_t,
}
#[test]
fn bindgen_test_layout_qc_type_state() {
    assert_eq!(
        ::core::mem::size_of::<qc_type_state>(),
        56usize,
        concat!("Size of: ", stringify!(qc_type_state))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_type_state>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_type_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).spc_timelimit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).ino_timelimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).rt_spc_timelimit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(rt_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).spc_warnlimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).ino_warnlimit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).rt_spc_warnlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(rt_spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).ino as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).blocks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_type_state>())).nextents as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(nextents)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_state {
    pub s_incoredqs: c_types::c_uint,
    pub s_state: [qc_type_state; 3usize],
}
#[test]
fn bindgen_test_layout_qc_state() {
    assert_eq!(
        ::core::mem::size_of::<qc_state>(),
        176usize,
        concat!("Size of: ", stringify!(qc_state))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_state>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_state>())).s_incoredqs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_state),
            "::",
            stringify!(s_incoredqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_state>())).s_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_state),
            "::",
            stringify!(s_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_info {
    pub i_fieldmask: c_types::c_int,
    pub i_flags: c_types::c_uint,
    pub i_spc_timelimit: c_types::c_uint,
    pub i_ino_timelimit: c_types::c_uint,
    pub i_rt_spc_timelimit: c_types::c_uint,
    pub i_spc_warnlimit: c_types::c_uint,
    pub i_ino_warnlimit: c_types::c_uint,
    pub i_rt_spc_warnlimit: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_qc_info() {
    assert_eq!(
        ::core::mem::size_of::<qc_info>(),
        32usize,
        concat!("Size of: ", stringify!(qc_info))
    );
    assert_eq!(
        ::core::mem::align_of::<qc_info>(),
        4usize,
        concat!("Alignment of ", stringify!(qc_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_fieldmask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_fieldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_spc_timelimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_ino_timelimit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_ino_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_rt_spc_timelimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_rt_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_spc_warnlimit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_ino_warnlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_ino_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<qc_info>())).i_rt_spc_warnlimit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_rt_spc_warnlimit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct quotactl_ops {
    pub quota_on: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: c_types::c_int,
            arg4: *const path,
        ) -> c_types::c_int,
    >,
    pub quota_off: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub quota_enable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub quota_disable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_uint) -> c_types::c_int,
    >,
    pub quota_sync: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub set_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: *mut qc_info,
        ) -> c_types::c_int,
    >,
    pub get_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> c_types::c_int,
    >,
    pub get_nextdqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut kqid,
            arg3: *mut qc_dqblk,
        ) -> c_types::c_int,
    >,
    pub set_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> c_types::c_int,
    >,
    pub get_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> c_types::c_int,
    >,
    pub rm_xquota: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: c_types::c_uint) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_quotactl_ops() {
    assert_eq!(
        ::core::mem::size_of::<quotactl_ops>(),
        88usize,
        concat!("Size of: ", stringify!(quotactl_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<quotactl_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(quotactl_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_on as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_enable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_disable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_sync as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).set_info as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(set_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_dqblk as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_nextdqblk as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_nextdqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).set_dqblk as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(set_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quotactl_ops>())).rm_xquota as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(rm_xquota)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quota_format_type {
    pub qf_fmt_id: c_types::c_int,
    pub qf_ops: *const quota_format_ops,
    pub qf_owner: *mut module,
    pub qf_next: *mut quota_format_type,
}
#[test]
fn bindgen_test_layout_quota_format_type() {
    assert_eq!(
        ::core::mem::size_of::<quota_format_type>(),
        32usize,
        concat!("Size of: ", stringify!(quota_format_type))
    );
    assert_eq!(
        ::core::mem::align_of::<quota_format_type>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_format_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_fmt_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_fmt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_owner as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_next)
        )
    );
}
impl Default for quota_format_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_info {
    pub flags: c_types::c_uint,
    pub dqio_sem: rw_semaphore,
    pub files: [*mut inode; 3usize],
    pub info: [mem_dqinfo; 3usize],
    pub ops: [*const quota_format_ops; 3usize],
}
#[test]
fn bindgen_test_layout_quota_info() {
    assert_eq!(
        ::core::mem::size_of::<quota_info>(),
        312usize,
        concat!("Size of: ", stringify!(quota_info))
    );
    assert_eq!(
        ::core::mem::align_of::<quota_info>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).dqio_sem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(dqio_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).files as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).info as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<quota_info>())).ops as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(ops)
        )
    );
}
impl Default for quota_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct writeback_control {
    _unused: [u8; 0],
}
pub const rw_hint_WRITE_LIFE_NOT_SET: rw_hint = 0;
pub const rw_hint_WRITE_LIFE_NONE: rw_hint = 1;
pub const rw_hint_WRITE_LIFE_SHORT: rw_hint = 2;
pub const rw_hint_WRITE_LIFE_MEDIUM: rw_hint = 3;
pub const rw_hint_WRITE_LIFE_LONG: rw_hint = 4;
pub const rw_hint_WRITE_LIFE_EXTREME: rw_hint = 5;
pub type rw_hint = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kiocb {
    pub ki_filp: *mut file,
    pub ki_pos: loff_t,
    pub ki_complete: ::core::option::Option<
        unsafe extern "C" fn(iocb: *mut kiocb, ret: c_types::c_long, ret2: c_types::c_long),
    >,
    pub private: *mut c_types::c_void,
    pub ki_flags: c_types::c_int,
    pub ki_hint: u16,
    pub ki_ioprio: u16,
}
#[test]
fn bindgen_test_layout_kiocb() {
    assert_eq!(
        ::core::mem::size_of::<kiocb>(),
        40usize,
        concat!("Size of: ", stringify!(kiocb))
    );
    assert_eq!(
        ::core::mem::align_of::<kiocb>(),
        8usize,
        concat!("Alignment of ", stringify!(kiocb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_filp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_filp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_complete as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).private as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_hint as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kiocb>())).ki_ioprio as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_ioprio)
        )
    );
}
impl Default for kiocb {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct address_space_operations {
    pub writepage: ::core::option::Option<
        unsafe extern "C" fn(page: *mut page, wbc: *mut writeback_control) -> c_types::c_int,
    >,
    pub readpage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut page) -> c_types::c_int,
    >,
    pub writepages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut writeback_control,
        ) -> c_types::c_int,
    >,
    pub set_page_dirty:
        ::core::option::Option<unsafe extern "C" fn(page: *mut page) -> c_types::c_int>,
    pub readpages: ::core::option::Option<
        unsafe extern "C" fn(
            filp: *mut file,
            mapping: *mut address_space,
            pages: *mut list_head,
            nr_pages: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub write_begin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: c_types::c_uint,
            flags: c_types::c_uint,
            pagep: *mut *mut page,
            fsdata: *mut *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub write_end: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: c_types::c_uint,
            copied: c_types::c_uint,
            page: *mut page,
            fsdata: *mut c_types::c_void,
        ) -> c_types::c_int,
    >,
    pub bmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
    >,
    pub invalidatepage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: c_types::c_uint, arg3: c_types::c_uint),
    >,
    pub releasepage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: gfp_t) -> c_types::c_int,
    >,
    pub freepage: ::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>,
    pub direct_IO: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, iter: *mut iov_iter) -> isize,
    >,
    pub migratepage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut page,
            arg3: *mut page,
            arg4: migrate_mode,
        ) -> c_types::c_int,
    >,
    pub isolate_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: isolate_mode_t) -> bool_,
    >,
    pub putback_page: ::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>,
    pub launder_page:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut page) -> c_types::c_int>,
    pub is_partially_uptodate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut page,
            arg2: c_types::c_ulong,
            arg3: c_types::c_ulong,
        ) -> c_types::c_int,
    >,
    pub is_dirty_writeback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: *mut bool_, arg3: *mut bool_),
    >,
    pub error_remove_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut page) -> c_types::c_int,
    >,
    pub swap_activate: ::core::option::Option<
        unsafe extern "C" fn(
            sis: *mut swap_info_struct,
            file: *mut file,
            span: *mut sector_t,
        ) -> c_types::c_int,
    >,
    pub swap_deactivate: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
}
#[test]
fn bindgen_test_layout_address_space_operations() {
    assert_eq!(
        ::core::mem::size_of::<address_space_operations>(),
        168usize,
        concat!("Size of: ", stringify!(address_space_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<address_space_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(address_space_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).writepage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(writepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).readpage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(readpage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).writepages as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(writepages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).set_page_dirty as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(set_page_dirty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).readpages as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(readpages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).write_begin as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(write_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).write_end as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space_operations>())).bmap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(bmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).invalidatepage as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(invalidatepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).releasepage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(releasepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).freepage as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(freepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).direct_IO as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(direct_IO)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).migratepage as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(migratepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).isolate_page as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(isolate_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).putback_page as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(putback_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).launder_page as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(launder_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).is_partially_uptodate as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(is_partially_uptodate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).is_dirty_writeback as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(is_dirty_writeback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).error_remove_page as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(error_remove_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).swap_activate as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(swap_activate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<address_space_operations>())).swap_deactivate as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(swap_deactivate)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct address_space {
    pub host: *mut inode,
    pub i_pages: radix_tree_root,
    pub i_mmap_writable: atomic_t,
    pub i_mmap: rb_root_cached,
    pub i_mmap_rwsem: rw_semaphore,
    pub nrpages: c_types::c_ulong,
    pub nrexceptional: c_types::c_ulong,
    pub writeback_index: c_types::c_ulong,
    pub a_ops: *const address_space_operations,
    pub flags: c_types::c_ulong,
    pub private_lock: spinlock_t,
    pub gfp_mask: gfp_t,
    pub private_list: list_head,
    pub private_data: *mut c_types::c_void,
    pub wb_err: errseq_t,
}
#[test]
fn bindgen_test_layout_address_space() {
    assert_eq!(
        ::core::mem::size_of::<address_space>(),
        168usize,
        concat!("Size of: ", stringify!(address_space))
    );
    assert_eq!(
        ::core::mem::align_of::<address_space>(),
        8usize,
        concat!("Alignment of ", stringify!(address_space))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).host as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).i_pages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).i_mmap_writable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap_writable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).i_mmap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).i_mmap_rwsem as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap_rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).nrpages as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(nrpages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).nrexceptional as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(nrexceptional)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).writeback_index as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(writeback_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).a_ops as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(a_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).flags as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).private_lock as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).gfp_mask as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).private_list as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).private_data as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<address_space>())).wb_err as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(wb_err)
        )
    );
}
impl Default for address_space {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request_queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct block_device {
    pub bd_dev: dev_t,
    pub bd_openers: c_types::c_int,
    pub bd_inode: *mut inode,
    pub bd_super: *mut super_block,
    pub bd_mutex: mutex,
    pub bd_claiming: *mut c_types::c_void,
    pub bd_holder: *mut c_types::c_void,
    pub bd_holders: c_types::c_int,
    pub bd_write_holder: bool_,
    pub bd_holder_disks: list_head,
    pub bd_contains: *mut block_device,
    pub bd_block_size: c_types::c_uint,
    pub bd_partno: u8,
    pub bd_part: *mut hd_struct,
    pub bd_part_count: c_types::c_uint,
    pub bd_invalidated: c_types::c_int,
    pub bd_disk: *mut gendisk,
    pub bd_queue: *mut request_queue,
    pub bd_bdi: *mut backing_dev_info,
    pub bd_list: list_head,
    pub bd_private: c_types::c_ulong,
    pub bd_fsfreeze_count: c_types::c_int,
    pub bd_fsfreeze_mutex: mutex,
}
#[test]
fn bindgen_test_layout_block_device() {
    assert_eq!(
        ::core::mem::size_of::<block_device>(),
        216usize,
        concat!("Size of: ", stringify!(block_device))
    );
    assert_eq!(
        ::core::mem::align_of::<block_device>(),
        8usize,
        concat!("Alignment of ", stringify!(block_device))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_openers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_openers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_inode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_super as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_mutex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_claiming as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_claiming)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_holder as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_holder)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_holders as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_holders)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_write_holder as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_write_holder)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_holder_disks as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_holder_disks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_contains as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_contains)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_block_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_partno as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_partno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_part as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_part)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_part_count as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_part_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_invalidated as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_invalidated)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_disk as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_disk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_queue as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_bdi as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_bdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_list as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_private as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_fsfreeze_count as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_fsfreeze_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<block_device>())).bd_fsfreeze_mutex as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(block_device),
            "::",
            stringify!(bd_fsfreeze_mutex)
        )
    );
}
impl Default for block_device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsnotify_mark_connector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_mode: umode_t,
    pub i_opflags: c_types::c_ushort,
    pub i_uid: kuid_t,
    pub i_gid: kgid_t,
    pub i_flags: c_types::c_uint,
    pub i_acl: *mut posix_acl,
    pub i_default_acl: *mut posix_acl,
    pub i_op: *const inode_operations,
    pub i_sb: *mut super_block,
    pub i_mapping: *mut address_space,
    pub i_security: *mut c_types::c_void,
    pub i_ino: c_types::c_ulong,
    pub __bindgen_anon_1: inode__bindgen_ty_1,
    pub i_rdev: dev_t,
    pub i_size: loff_t,
    pub i_atime: timespec64,
    pub i_mtime: timespec64,
    pub i_ctime: timespec64,
    pub i_lock: spinlock_t,
    pub i_bytes: c_types::c_ushort,
    pub i_blkbits: u8,
    pub i_write_hint: u8,
    pub i_blocks: blkcnt_t,
    pub i_state: c_types::c_ulong,
    pub i_rwsem: rw_semaphore,
    pub dirtied_when: c_types::c_ulong,
    pub dirtied_time_when: c_types::c_ulong,
    pub i_hash: hlist_node,
    pub i_io_list: list_head,
    pub i_wb: *mut bdi_writeback,
    pub i_wb_frn_winner: c_types::c_int,
    pub i_wb_frn_avg_time: u16,
    pub i_wb_frn_history: u16,
    pub i_lru: list_head,
    pub i_sb_list: list_head,
    pub i_wb_list: list_head,
    pub __bindgen_anon_2: inode__bindgen_ty_2,
    pub i_version: atomic64_t,
    pub i_sequence: atomic64_t,
    pub i_count: atomic_t,
    pub i_dio_count: atomic_t,
    pub i_writecount: atomic_t,
    pub i_readcount: atomic_t,
    pub i_fop: *const file_operations,
    pub i_flctx: *mut file_lock_context,
    pub i_data: address_space,
    pub i_devices: list_head,
    pub __bindgen_anon_3: inode__bindgen_ty_3,
    pub i_generation: __u32,
    pub i_fsnotify_mask: __u32,
    pub i_fsnotify_marks: *mut fsnotify_mark_connector,
    pub i_crypt_info: *mut fscrypt_info,
    pub i_private: *mut c_types::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_1 {
    pub i_nlink: c_types::c_uint,
    pub __i_nlink: c_types::c_uint,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<inode__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<inode__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_1>())).i_nlink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_1),
            "::",
            stringify!(i_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_1>())).__i_nlink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_1),
            "::",
            stringify!(__i_nlink)
        )
    );
}
impl Default for inode__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_2 {
    pub i_dentry: hlist_head,
    pub i_rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<inode__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<inode__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_2>())).i_dentry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_2),
            "::",
            stringify!(i_dentry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_2>())).i_rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_2),
            "::",
            stringify!(i_rcu)
        )
    );
}
impl Default for inode__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_3 {
    pub i_pipe: *mut pipe_inode_info,
    pub i_bdev: *mut block_device,
    pub i_cdev: *mut cdev,
    pub i_link: *mut c_types::c_char,
    pub i_dir_seq: c_types::c_uint,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<inode__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<inode__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_pipe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_bdev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_bdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_cdev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_cdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_dir_seq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_dir_seq)
        )
    );
}
impl Default for inode__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_inode() {
    assert_eq!(
        ::core::mem::size_of::<inode>(),
        600usize,
        concat!("Size of: ", stringify!(inode))
    );
    assert_eq!(
        ::core::mem::align_of::<inode>(),
        8usize,
        concat!("Alignment of ", stringify!(inode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_opflags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_opflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_acl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_default_acl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_default_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_op as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_sb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_mapping as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_security as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_ino as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_rdev as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_atime as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_mtime as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_ctime as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_bytes as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_blkbits as *const _ as usize },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_blkbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_write_hint as *const _ as usize },
        143usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_write_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_blocks as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_state as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_rwsem as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).dirtied_when as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(dirtied_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).dirtied_time_when as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(dirtied_time_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_hash as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_io_list as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_io_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_winner as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_frn_winner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_avg_time as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_frn_avg_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_history as *const _ as usize },
        262usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_frn_history)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_lru as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_sb_list as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_wb_list as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_version as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_sequence as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_count as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_dio_count as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_dio_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_writecount as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_writecount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_readcount as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_readcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_fop as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_flctx as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_flctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_data as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_devices as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_generation as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_generation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_fsnotify_mask as *const _ as usize },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_fsnotify_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_fsnotify_marks as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_fsnotify_marks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_crypt_info as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_crypt_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode>())).i_private as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_private)
        )
    );
}
impl Default for inode {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fown_struct {
    pub lock: rwlock_t,
    pub pid: *mut pid,
    pub pid_type: pid_type,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub signum: c_types::c_int,
}
#[test]
fn bindgen_test_layout_fown_struct() {
    assert_eq!(
        ::core::mem::size_of::<fown_struct>(),
        32usize,
        concat!("Size of: ", stringify!(fown_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<fown_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(fown_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).pid_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(pid_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).uid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).euid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(euid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fown_struct>())).signum as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(signum)
        )
    );
}
impl Default for fown_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct file_ra_state {
    pub start: c_types::c_ulong,
    pub size: c_types::c_uint,
    pub async_size: c_types::c_uint,
    pub ra_pages: c_types::c_uint,
    pub mmap_miss: c_types::c_uint,
    pub prev_pos: loff_t,
}
#[test]
fn bindgen_test_layout_file_ra_state() {
    assert_eq!(
        ::core::mem::size_of::<file_ra_state>(),
        32usize,
        concat!("Size of: ", stringify!(file_ra_state))
    );
    assert_eq!(
        ::core::mem::align_of::<file_ra_state>(),
        8usize,
        concat!("Alignment of ", stringify!(file_ra_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).async_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(async_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).ra_pages as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(ra_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).mmap_miss as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(mmap_miss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_ra_state>())).prev_pos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(prev_pos)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub f_u: file__bindgen_ty_1,
    pub f_path: path,
    pub f_inode: *mut inode,
    pub f_op: *const file_operations,
    pub f_lock: spinlock_t,
    pub f_write_hint: rw_hint,
    pub f_count: atomic_long_t,
    pub f_flags: c_types::c_uint,
    pub f_mode: fmode_t,
    pub f_pos_lock: mutex,
    pub f_pos: loff_t,
    pub f_owner: fown_struct,
    pub f_cred: *const cred,
    pub f_ra: file_ra_state,
    pub f_version: u64,
    pub f_security: *mut c_types::c_void,
    pub private_data: *mut c_types::c_void,
    pub f_ep_links: list_head,
    pub f_tfile_llink: list_head,
    pub f_mapping: *mut address_space,
    pub f_wb_err: errseq_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_1 {
    pub fu_llist: llist_node,
    pub fu_rcuhead: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_file__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<file__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(file__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<file__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(file__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file__bindgen_ty_1>())).fu_llist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file__bindgen_ty_1),
            "::",
            stringify!(fu_llist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file__bindgen_ty_1>())).fu_rcuhead as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file__bindgen_ty_1),
            "::",
            stringify!(fu_rcuhead)
        )
    );
}
impl Default for file__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_file() {
    assert_eq!(
        ::core::mem::size_of::<file>(),
        256usize,
        concat!("Size of: ", stringify!(file))
    );
    assert_eq!(
        ::core::mem::align_of::<file>(),
        8usize,
        concat!("Alignment of ", stringify!(file))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_u as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(file), "::", stringify!(f_u))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_path as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_inode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_op as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_lock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_write_hint as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_write_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_mode as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_pos_lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_pos_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_pos as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_owner as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_cred as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_ra as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_ra)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_version as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_security as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).private_data as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_ep_links as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_ep_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_tfile_llink as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_tfile_llink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_mapping as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file>())).f_wb_err as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_wb_err)
        )
    );
}
impl Default for file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type fl_owner_t = *mut c_types::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct file_lock_operations {
    pub fl_copy_lock:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut file_lock)>,
    pub fl_release_private: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
}
#[test]
fn bindgen_test_layout_file_lock_operations() {
    assert_eq!(
        ::core::mem::size_of::<file_lock_operations>(),
        16usize,
        concat!("Size of: ", stringify!(file_lock_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock_operations>())).fl_copy_lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_operations),
            "::",
            stringify!(fl_copy_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock_operations>())).fl_release_private as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_operations),
            "::",
            stringify!(fl_release_private)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lock_manager_operations {
    pub lm_compare_owner: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut file_lock) -> c_types::c_int,
    >,
    pub lm_owner_key:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> c_types::c_ulong>,
    pub lm_get_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t) -> fl_owner_t>,
    pub lm_put_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t)>,
    pub lm_notify: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
    pub lm_grant: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub lm_break: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
    pub lm_change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_lock,
            arg2: c_types::c_int,
            arg3: *mut list_head,
        ) -> c_types::c_int,
    >,
    pub lm_setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut *mut c_types::c_void),
    >,
}
#[test]
fn bindgen_test_layout_lock_manager_operations() {
    assert_eq!(
        ::core::mem::size_of::<lock_manager_operations>(),
        72usize,
        concat!("Size of: ", stringify!(lock_manager_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<lock_manager_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(lock_manager_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_compare_owner as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_compare_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_owner_key as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_owner_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_get_owner as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_get_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_put_owner as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_put_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_notify as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_notify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_grant as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_grant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_break as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_break)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_change as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<lock_manager_operations>())).lm_setup as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_setup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlm_lockowner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_lock_info {
    pub state: u32,
    pub owner: *mut nlm_lockowner,
    pub list: list_head,
}
#[test]
fn bindgen_test_layout_nfs_lock_info() {
    assert_eq!(
        ::core::mem::size_of::<nfs_lock_info>(),
        32usize,
        concat!("Size of: ", stringify!(nfs_lock_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nfs_lock_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nfs_lock_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs_lock_info>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs_lock_info>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs_lock_info>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(list)
        )
    );
}
impl Default for nfs_lock_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_lock_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_lock_info {
    pub owner: *mut nfs4_lock_state,
}
#[test]
fn bindgen_test_layout_nfs4_lock_info() {
    assert_eq!(
        ::core::mem::size_of::<nfs4_lock_info>(),
        8usize,
        concat!("Size of: ", stringify!(nfs4_lock_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nfs4_lock_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nfs4_lock_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nfs4_lock_info>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs4_lock_info),
            "::",
            stringify!(owner)
        )
    );
}
impl Default for nfs4_lock_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock {
    pub fl_next: *mut file_lock,
    pub fl_list: list_head,
    pub fl_link: hlist_node,
    pub fl_block: list_head,
    pub fl_owner: fl_owner_t,
    pub fl_flags: c_types::c_uint,
    pub fl_type: c_types::c_uchar,
    pub fl_pid: c_types::c_uint,
    pub fl_link_cpu: c_types::c_int,
    pub fl_wait: wait_queue_head_t,
    pub fl_file: *mut file,
    pub fl_start: loff_t,
    pub fl_end: loff_t,
    pub fl_fasync: *mut fasync_struct,
    pub fl_break_time: c_types::c_ulong,
    pub fl_downgrade_time: c_types::c_ulong,
    pub fl_ops: *const file_lock_operations,
    pub fl_lmops: *const lock_manager_operations,
    pub fl_u: file_lock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file_lock__bindgen_ty_1 {
    pub nfs_fl: nfs_lock_info,
    pub nfs4_fl: nfs4_lock_info,
    pub afs: file_lock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lock__bindgen_ty_1__bindgen_ty_1 {
    pub link: list_head,
    pub state: c_types::c_int,
}
#[test]
fn bindgen_test_layout_file_lock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<file_lock__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock__bindgen_ty_1__bindgen_ty_1>())).link as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock__bindgen_ty_1__bindgen_ty_1>())).state as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(state)
        )
    );
}
impl Default for file_lock__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_file_lock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<file_lock__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(file_lock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock__bindgen_ty_1>())).nfs_fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(nfs_fl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_lock__bindgen_ty_1>())).nfs4_fl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(nfs4_fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock__bindgen_ty_1>())).afs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(afs)
        )
    );
}
impl Default for file_lock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_file_lock() {
    assert_eq!(
        ::core::mem::size_of::<file_lock>(),
        200usize,
        concat!("Size of: ", stringify!(file_lock))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_link as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_block as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_owner as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_type as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_pid as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_link_cpu as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_link_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_wait as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_file as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_start as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_end as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_fasync as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_fasync)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_break_time as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_break_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_downgrade_time as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_downgrade_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_ops as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_lmops as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_lmops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock>())).fl_u as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_u)
        )
    );
}
impl Default for file_lock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock_context {
    pub flc_lock: spinlock_t,
    pub flc_flock: list_head,
    pub flc_posix: list_head,
    pub flc_lease: list_head,
}
#[test]
fn bindgen_test_layout_file_lock_context() {
    assert_eq!(
        ::core::mem::size_of::<file_lock_context>(),
        56usize,
        concat!("Size of: ", stringify!(file_lock_context))
    );
    assert_eq!(
        ::core::mem::align_of::<file_lock_context>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_flock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_flock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_posix as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_posix)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_lock_context>())).flc_lease as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_lease)
        )
    );
}
impl Default for file_lock_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct files_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fasync_struct {
    pub fa_lock: rwlock_t,
    pub magic: c_types::c_int,
    pub fa_fd: c_types::c_int,
    pub fa_next: *mut fasync_struct,
    pub fa_file: *mut file,
    pub fa_rcu: callback_head,
}
#[test]
fn bindgen_test_layout_fasync_struct() {
    assert_eq!(
        ::core::mem::size_of::<fasync_struct>(),
        48usize,
        concat!("Size of: ", stringify!(fasync_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<fasync_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(fasync_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).magic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_fd as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_file as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_rcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_rcu)
        )
    );
}
impl Default for fasync_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sb_writers {
    pub frozen: c_types::c_int,
    pub wait_unfrozen: wait_queue_head_t,
    pub rw_sem: [percpu_rw_semaphore; 3usize],
}
#[test]
fn bindgen_test_layout_sb_writers() {
    assert_eq!(
        ::core::mem::size_of::<sb_writers>(),
        416usize,
        concat!("Size of: ", stringify!(sb_writers))
    );
    assert_eq!(
        ::core::mem::align_of::<sb_writers>(),
        8usize,
        concat!("Alignment of ", stringify!(sb_writers))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb_writers>())).frozen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(frozen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb_writers>())).wait_unfrozen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(wait_unfrozen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sb_writers>())).rw_sem as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(rw_sem)
        )
    );
}
impl Default for sb_writers {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct super_block {
    pub s_list: list_head,
    pub s_dev: dev_t,
    pub s_blocksize_bits: c_types::c_uchar,
    pub s_blocksize: c_types::c_ulong,
    pub s_maxbytes: loff_t,
    pub s_type: *mut file_system_type,
    pub s_op: *const super_operations,
    pub dq_op: *const dquot_operations,
    pub s_qcop: *const quotactl_ops,
    pub s_export_op: *const export_operations,
    pub s_flags: c_types::c_ulong,
    pub s_iflags: c_types::c_ulong,
    pub s_magic: c_types::c_ulong,
    pub s_root: *mut dentry,
    pub s_umount: rw_semaphore,
    pub s_count: c_types::c_int,
    pub s_active: atomic_t,
    pub s_security: *mut c_types::c_void,
    pub s_xattr: *mut *mut xattr_handler,
    pub s_cop: *const fscrypt_operations,
    pub s_roots: hlist_bl_head,
    pub s_mounts: list_head,
    pub s_bdev: *mut block_device,
    pub s_bdi: *mut backing_dev_info,
    pub s_mtd: *mut mtd_info,
    pub s_instances: hlist_node,
    pub s_quota_types: c_types::c_uint,
    pub s_dquot: quota_info,
    pub s_writers: sb_writers,
    pub s_id: [c_types::c_char; 32usize],
    pub s_uuid: uuid_t,
    pub s_fs_info: *mut c_types::c_void,
    pub s_max_links: c_types::c_uint,
    pub s_mode: fmode_t,
    pub s_time_gran: u32,
    pub s_vfs_rename_mutex: mutex,
    pub s_subtype: *mut c_types::c_char,
    pub s_d_op: *const dentry_operations,
    pub cleancache_poolid: c_types::c_int,
    pub s_shrink: shrinker,
    pub s_remove_count: atomic_long_t,
    pub s_fsnotify_inode_refs: atomic_long_t,
    pub s_readonly_remount: c_types::c_int,
    pub s_dio_done_wq: *mut workqueue_struct,
    pub s_pins: hlist_head,
    pub s_user_ns: *mut user_namespace,
    pub __bindgen_padding_0: [u64; 7usize],
    pub s_dentry_lru: list_lru,
    pub __bindgen_padding_1: [u64; 4usize],
    pub s_inode_lru: list_lru,
    pub rcu: callback_head,
    pub destroy_work: work_struct,
    pub s_sync_lock: mutex,
    pub s_stack_depth: c_types::c_int,
    pub __bindgen_padding_2: [u32; 3usize],
    pub s_inode_list_lock: spinlock_t,
    pub s_inodes: list_head,
    pub s_inode_wblist_lock: spinlock_t,
    pub s_inodes_wb: list_head,
    pub __bindgen_padding_3: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_super_block() {
    assert_eq!(
        ::core::mem::size_of::<super_block>(),
        1536usize,
        concat!("Size of: ", stringify!(super_block))
    );
    assert_eq!(
        ::core::mem::align_of::<super_block>(),
        64usize,
        concat!("Alignment of ", stringify!(super_block))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_blocksize_bits as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_blocksize_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_blocksize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_blocksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_maxbytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_maxbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_op as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).dq_op as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(dq_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_qcop as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_qcop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_export_op as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_export_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_iflags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_iflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_magic as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_root as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_umount as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_umount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_count as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_active as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_security as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_xattr as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_xattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_cop as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_cop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_roots as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_roots)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_mounts as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mounts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_bdev as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_bdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_bdi as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_bdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_mtd as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mtd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_instances as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_instances)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_quota_types as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_quota_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dquot as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_writers as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_id as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_uuid as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_fs_info as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_fs_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_max_links as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_max_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_mode as *const _ as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_time_gran as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_time_gran)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_vfs_rename_mutex as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_vfs_rename_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_subtype as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_subtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_d_op as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_d_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).cleancache_poolid as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(cleancache_poolid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_shrink as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_shrink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_remove_count as *const _ as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_remove_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_block>())).s_fsnotify_inode_refs as *const _ as usize
        },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_fsnotify_inode_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_readonly_remount as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_readonly_remount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dio_done_wq as *const _ as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dio_done_wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_pins as *const _ as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_pins)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_user_ns as *const _ as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_user_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_dentry_lru as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dentry_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inode_lru as *const _ as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).rcu as *const _ as usize },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).destroy_work as *const _ as usize },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(destroy_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_sync_lock as *const _ as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_sync_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_stack_depth as *const _ as usize },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_stack_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inode_list_lock as *const _ as usize },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_list_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inodes as *const _ as usize },
        1480usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inodes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_block>())).s_inode_wblist_lock as *const _ as usize
        },
        1496usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_wblist_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_block>())).s_inodes_wb as *const _ as usize },
        1504usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inodes_wb)
        )
    );
}
impl Default for super_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiemap_extent_info {
    pub fi_flags: c_types::c_uint,
    pub fi_extents_mapped: c_types::c_uint,
    pub fi_extents_max: c_types::c_uint,
    pub fi_extents_start: *mut fiemap_extent,
}
#[test]
fn bindgen_test_layout_fiemap_extent_info() {
    assert_eq!(
        ::core::mem::size_of::<fiemap_extent_info>(),
        24usize,
        concat!("Size of: ", stringify!(fiemap_extent_info))
    );
    assert_eq!(
        ::core::mem::align_of::<fiemap_extent_info>(),
        8usize,
        concat!("Alignment of ", stringify!(fiemap_extent_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fiemap_extent_info>())).fi_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fiemap_extent_info>())).fi_extents_mapped as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_extents_mapped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fiemap_extent_info>())).fi_extents_max as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_extents_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<fiemap_extent_info>())).fi_extents_start as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fiemap_extent_info),
            "::",
            stringify!(fi_extents_start)
        )
    );
}
impl Default for fiemap_extent_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type filldir_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dir_context,
        arg2: *const c_types::c_char,
        arg3: c_types::c_int,
        arg4: loff_t,
        arg5: u64,
        arg6: c_types::c_uint,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dir_context {
    pub actor: filldir_t,
    pub pos: loff_t,
}
#[test]
fn bindgen_test_layout_dir_context() {
    assert_eq!(
        ::core::mem::size_of::<dir_context>(),
        16usize,
        concat!("Size of: ", stringify!(dir_context))
    );
    assert_eq!(
        ::core::mem::align_of::<dir_context>(),
        8usize,
        concat!("Alignment of ", stringify!(dir_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dir_context>())).actor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dir_context),
            "::",
            stringify!(actor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dir_context>())).pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dir_context),
            "::",
            stringify!(pos)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct inode_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: c_types::c_uint,
        ) -> *mut dentry,
    >,
    pub get_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut delayed_call,
        ) -> *const c_types::c_char,
    >,
    pub permission: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: c_types::c_int) -> c_types::c_int,
    >,
    pub get_acl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: c_types::c_int) -> *mut posix_acl,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut c_types::c_char,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: umode_t,
            arg4: bool_,
        ) -> c_types::c_int,
    >,
    pub link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut dentry,
        ) -> c_types::c_int,
    >,
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *const c_types::c_char,
        ) -> c_types::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry, arg3: umode_t) -> c_types::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub mknod: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: umode_t,
            arg4: dev_t,
        ) -> c_types::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut inode,
            arg4: *mut dentry,
            arg5: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub setattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut iattr) -> c_types::c_int,
    >,
    pub getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const path,
            arg2: *mut kstat,
            arg3: u32,
            arg4: c_types::c_uint,
        ) -> c_types::c_int,
    >,
    pub listxattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut c_types::c_char, arg3: usize) -> isize,
    >,
    pub fiemap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut fiemap_extent_info,
            start: u64,
            len: u64,
        ) -> c_types::c_int,
    >,
    pub update_time: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut timespec64,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub atomic_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut file,
            open_flag: c_types::c_uint,
            create_mode: umode_t,
        ) -> c_types::c_int,
    >,
    pub tmpfile: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry, arg3: umode_t) -> c_types::c_int,
    >,
    pub set_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut posix_acl,
            arg3: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub __bindgen_padding_0: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_inode_operations() {
    assert_eq!(
        ::core::mem::size_of::<inode_operations>(),
        192usize,
        concat!("Size of: ", stringify!(inode_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<inode_operations>(),
        64usize,
        concat!("Alignment of ", stringify!(inode_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).lookup as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).get_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(get_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).permission as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(permission)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).get_acl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(get_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).readlink as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(readlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).create as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).link as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).unlink as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(unlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).symlink as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(symlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).mkdir as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).rmdir as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(rmdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).mknod as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(mknod)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).rename as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).setattr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(setattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).getattr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(getattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).listxattr as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(listxattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).fiemap as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(fiemap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).update_time as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(update_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).atomic_open as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(atomic_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).tmpfile as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(tmpfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<inode_operations>())).set_acl as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(set_acl)
        )
    );
}
impl Default for inode_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct super_operations {
    pub alloc_inode:
        ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block) -> *mut inode>,
    pub destroy_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub dirty_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, flags: c_types::c_int)>,
    pub write_inode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, wbc: *mut writeback_control) -> c_types::c_int,
    >,
    pub drop_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> c_types::c_int>,
    pub evict_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub put_super: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub sync_fs: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, wait: c_types::c_int) -> c_types::c_int,
    >,
    pub freeze_super:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub freeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub thaw_super:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub unfreeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> c_types::c_int>,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> c_types::c_int,
    >,
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut c_types::c_int,
            arg3: *mut c_types::c_char,
        ) -> c_types::c_int,
    >,
    pub umount_begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub show_devname: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub show_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> c_types::c_int,
    >,
    pub quota_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: *mut c_types::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub quota_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: c_types::c_int,
            arg3: *const c_types::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub get_dquots:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut *mut dquot>,
    pub bdev_try_to_free_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut page,
            arg3: gfp_t,
        ) -> c_types::c_int,
    >,
    pub nr_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut shrink_control) -> c_types::c_long,
    >,
    pub free_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut shrink_control) -> c_types::c_long,
    >,
}
#[test]
fn bindgen_test_layout_super_operations() {
    assert_eq!(
        ::core::mem::size_of::<super_operations>(),
        200usize,
        concat!("Size of: ", stringify!(super_operations))
    );
    assert_eq!(
        ::core::mem::align_of::<super_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(super_operations))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).alloc_inode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(alloc_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).destroy_inode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(destroy_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).dirty_inode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(dirty_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).write_inode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(write_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).drop_inode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(drop_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).evict_inode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(evict_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).put_super as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(put_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).sync_fs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(sync_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).freeze_super as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(freeze_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).freeze_fs as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(freeze_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).thaw_super as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(thaw_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).unfreeze_fs as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(unfreeze_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).statfs as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(statfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).remount_fs as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(remount_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).umount_begin as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(umount_begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_options as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_devname as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_devname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_path as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).show_stats as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).quota_read as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(quota_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).quota_write as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(quota_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<super_operations>())).get_dquots as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(get_dquots)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_operations>())).bdev_try_to_free_page as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(bdev_try_to_free_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_operations>())).nr_cached_objects as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(nr_cached_objects)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<super_operations>())).free_cached_objects as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(free_cached_objects)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_system_type {
    pub name: *const c_types::c_char,
    pub fs_flags: c_types::c_int,
    pub mount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_system_type,
            arg2: c_types::c_int,
            arg3: *const c_types::c_char,
            arg4: *mut c_types::c_void,
        ) -> *mut dentry,
    >,
    pub kill_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub owner: *mut module,
    pub next: *mut file_system_type,
    pub fs_supers: hlist_head,
    pub s_lock_key: lock_class_key,
    pub s_umount_key: lock_class_key,
    pub s_vfs_rename_key: lock_class_key,
    pub s_writers_key: [lock_class_key; 3usize],
    pub i_lock_key: lock_class_key,
    pub i_mutex_key: lock_class_key,
    pub i_mutex_dir_key: lock_class_key,
}
#[test]
fn bindgen_test_layout_file_system_type() {
    assert_eq!(
        ::core::mem::size_of::<file_system_type>(),
        56usize,
        concat!("Size of: ", stringify!(file_system_type))
    );
    assert_eq!(
        ::core::mem::align_of::<file_system_type>(),
        8usize,
        concat!("Alignment of ", stringify!(file_system_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).fs_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(fs_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).mount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(mount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).kill_sb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(kill_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).owner as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).fs_supers as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(fs_supers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).s_lock_key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).s_umount_key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_umount_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_system_type>())).s_vfs_rename_key as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_vfs_rename_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).s_writers_key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_writers_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).i_lock_key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<file_system_type>())).i_mutex_key as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_mutex_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<file_system_type>())).i_mutex_dir_key as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_mutex_dir_key)
        )
    );
}
impl Default for file_system_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mount_nodev(
        fs_type: *mut file_system_type,
        flags: c_types::c_int,
        data: *mut c_types::c_void,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut c_types::c_void,
                arg3: c_types::c_int,
            ) -> c_types::c_int,
        >,
    ) -> *mut dentry;
}
extern "C" {
    pub fn kill_litter_super(sb: *mut super_block);
}
extern "C" {
    pub fn register_filesystem(arg1: *mut file_system_type) -> c_types::c_int;
}
extern "C" {
    pub fn unregister_filesystem(arg1: *mut file_system_type) -> c_types::c_int;
}
extern "C" {
    pub fn alloc_chrdev_region(
        arg1: *mut dev_t,
        arg2: c_types::c_uint,
        arg3: c_types::c_uint,
        arg4: *const c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn unregister_chrdev_region(arg1: dev_t, arg2: c_types::c_uint);
}
pub type proc_handler = ::core::option::Option<
    unsafe extern "C" fn(
        ctl: *mut ctl_table,
        write: c_types::c_int,
        buffer: *mut c_types::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_poll {
    pub event: atomic_t,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_ctl_table_poll() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_poll>(),
        32usize,
        concat!("Size of: ", stringify!(ctl_table_poll))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_poll>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_poll))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_poll>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_poll),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_poll>())).wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_poll),
            "::",
            stringify!(wait)
        )
    );
}
impl Default for ctl_table_poll {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table {
    pub procname: *const c_types::c_char,
    pub data: *mut c_types::c_void,
    pub maxlen: c_types::c_int,
    pub mode: umode_t,
    pub child: *mut ctl_table,
    pub proc_handler: proc_handler,
    pub poll: *mut ctl_table_poll,
    pub extra1: *mut c_types::c_void,
    pub extra2: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_ctl_table() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table>(),
        64usize,
        concat!("Size of: ", stringify!(ctl_table))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).procname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(procname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).maxlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).child as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).proc_handler as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(proc_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).poll as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).extra1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(extra1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table>())).extra2 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(extra2)
        )
    );
}
impl Default for ctl_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_node {
    pub node: rb_node,
    pub header: *mut ctl_table_header,
}
#[test]
fn bindgen_test_layout_ctl_node() {
    assert_eq!(
        ::core::mem::size_of::<ctl_node>(),
        32usize,
        concat!("Size of: ", stringify!(ctl_node))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_node>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_node>())).header as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_node),
            "::",
            stringify!(header)
        )
    );
}
impl Default for ctl_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
    pub unregistering: *mut completion,
    pub ctl_table_arg: *mut ctl_table,
    pub root: *mut ctl_table_root,
    pub set: *mut ctl_table_set,
    pub parent: *mut ctl_dir,
    pub node: *mut ctl_node,
    pub inodes: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ctl_table_header__bindgen_ty_1 {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1__bindgen_ty_1,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub ctl_table: *mut ctl_table,
    pub used: c_types::c_int,
    pub count: c_types::c_int,
    pub nreg: c_types::c_int,
}
#[test]
fn bindgen_test_layout_ctl_table_header__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).ctl_table
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ctl_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).used
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).count
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).nreg
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(nreg)
        )
    );
}
impl Default for ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ctl_table_header__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_header__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(ctl_table_header__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_header__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_header__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1>())).rcu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
impl Default for ctl_table_header__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ctl_table_header() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_header>(),
        80usize,
        concat!("Size of: ", stringify!(ctl_table_header))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_header>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_header))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).unregistering as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(unregistering)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).ctl_table_arg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(ctl_table_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).set as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).parent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).node as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_header>())).inodes as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(inodes)
        )
    );
}
impl Default for ctl_table_header {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_dir {
    pub header: ctl_table_header,
    pub root: rb_root,
}
#[test]
fn bindgen_test_layout_ctl_dir() {
    assert_eq!(
        ::core::mem::size_of::<ctl_dir>(),
        88usize,
        concat!("Size of: ", stringify!(ctl_dir))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_dir>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_dir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_dir>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_dir),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_dir>())).root as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_dir),
            "::",
            stringify!(root)
        )
    );
}
impl Default for ctl_dir {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_set {
    pub is_seen:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ctl_table_set) -> c_types::c_int>,
    pub dir: ctl_dir,
}
#[test]
fn bindgen_test_layout_ctl_table_set() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_set>(),
        96usize,
        concat!("Size of: ", stringify!(ctl_table_set))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_set>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_set>())).is_seen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_set),
            "::",
            stringify!(is_seen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_set>())).dir as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_set),
            "::",
            stringify!(dir)
        )
    );
}
impl Default for ctl_table_set {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_root {
    pub default_set: ctl_table_set,
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(root: *mut ctl_table_root) -> *mut ctl_table_set,
    >,
    pub set_ownership: ::core::option::Option<
        unsafe extern "C" fn(
            head: *mut ctl_table_header,
            table: *mut ctl_table,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ),
    >,
    pub permissions: ::core::option::Option<
        unsafe extern "C" fn(head: *mut ctl_table_header, table: *mut ctl_table) -> c_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_ctl_table_root() {
    assert_eq!(
        ::core::mem::size_of::<ctl_table_root>(),
        120usize,
        concat!("Size of: ", stringify!(ctl_table_root))
    );
    assert_eq!(
        ::core::mem::align_of::<ctl_table_root>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_root))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).default_set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(default_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).lookup as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).set_ownership as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(set_ownership)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctl_table_root>())).permissions as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(permissions)
        )
    );
}
impl Default for ctl_table_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn register_sysctl(
        path: *const c_types::c_char,
        table: *mut ctl_table,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn unregister_sysctl_table(table: *mut ctl_table_header);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdso_image {
    pub data: *mut c_types::c_void,
    pub size: c_types::c_ulong,
    pub alt: c_types::c_ulong,
    pub alt_len: c_types::c_ulong,
    pub sym_vvar_start: c_types::c_long,
    pub sym_vvar_page: c_types::c_long,
    pub sym_hpet_page: c_types::c_long,
    pub sym_pvclock_page: c_types::c_long,
    pub sym_hvclock_page: c_types::c_long,
    pub sym_VDSO32_NOTE_MASK: c_types::c_long,
    pub sym___kernel_sigreturn: c_types::c_long,
    pub sym___kernel_rt_sigreturn: c_types::c_long,
    pub sym___kernel_vsyscall: c_types::c_long,
    pub sym_int80_landing_pad: c_types::c_long,
}
#[test]
fn bindgen_test_layout_vdso_image() {
    assert_eq!(
        ::core::mem::size_of::<vdso_image>(),
        112usize,
        concat!("Size of: ", stringify!(vdso_image))
    );
    assert_eq!(
        ::core::mem::align_of::<vdso_image>(),
        8usize,
        concat!("Alignment of ", stringify!(vdso_image))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).alt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(alt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).alt_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(alt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_vvar_start as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_vvar_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_vvar_page as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_vvar_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_hpet_page as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_hpet_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_pvclock_page as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_pvclock_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_hvclock_page as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_hvclock_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym_VDSO32_NOTE_MASK as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_VDSO32_NOTE_MASK)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym___kernel_sigreturn as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym___kernel_sigreturn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym___kernel_rt_sigreturn as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym___kernel_rt_sigreturn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym___kernel_vsyscall as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym___kernel_vsyscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<vdso_image>())).sym_int80_landing_pad as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vdso_image),
            "::",
            stringify!(sym_int80_landing_pad)
        )
    );
}
impl Default for vdso_image {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type Elf64_Addr = __u64;
pub type Elf64_Half = __u16;
pub type Elf64_Off = __u64;
pub type Elf64_Word = __u32;
pub type Elf64_Xword = __u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elf64_sym {
    pub st_name: Elf64_Word,
    pub st_info: c_types::c_uchar,
    pub st_other: c_types::c_uchar,
    pub st_shndx: Elf64_Half,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_elf64_sym() {
    assert_eq!(
        ::core::mem::size_of::<elf64_sym>(),
        24usize,
        concat!("Size of: ", stringify!(elf64_sym))
    );
    assert_eq!(
        ::core::mem::align_of::<elf64_sym>(),
        8usize,
        concat!("Alignment of ", stringify!(elf64_sym))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_info as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_other as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_other)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_shndx as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_shndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_sym),
            "::",
            stringify!(st_size)
        )
    );
}
pub type Elf64_Sym = elf64_sym;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elf64_hdr {
    pub e_ident: [c_types::c_uchar; 16usize],
    pub e_type: Elf64_Half,
    pub e_machine: Elf64_Half,
    pub e_version: Elf64_Word,
    pub e_entry: Elf64_Addr,
    pub e_phoff: Elf64_Off,
    pub e_shoff: Elf64_Off,
    pub e_flags: Elf64_Word,
    pub e_ehsize: Elf64_Half,
    pub e_phentsize: Elf64_Half,
    pub e_phnum: Elf64_Half,
    pub e_shentsize: Elf64_Half,
    pub e_shnum: Elf64_Half,
    pub e_shstrndx: Elf64_Half,
}
#[test]
fn bindgen_test_layout_elf64_hdr() {
    assert_eq!(
        ::core::mem::size_of::<elf64_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(elf64_hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<elf64_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(elf64_hdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_ident as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_ident)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_machine as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_machine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phoff as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_phoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_ehsize as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_ehsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phentsize as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_phentsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phnum as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_phnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shentsize as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shentsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shnum as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shstrndx as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_hdr),
            "::",
            stringify!(e_shstrndx)
        )
    );
}
pub type Elf64_Ehdr = elf64_hdr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elf64_shdr {
    pub sh_name: Elf64_Word,
    pub sh_type: Elf64_Word,
    pub sh_flags: Elf64_Xword,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: Elf64_Off,
    pub sh_size: Elf64_Xword,
    pub sh_link: Elf64_Word,
    pub sh_info: Elf64_Word,
    pub sh_addralign: Elf64_Xword,
    pub sh_entsize: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_elf64_shdr() {
    assert_eq!(
        ::core::mem::size_of::<elf64_shdr>(),
        64usize,
        concat!("Size of: ", stringify!(elf64_shdr))
    );
    assert_eq!(
        ::core::mem::align_of::<elf64_shdr>(),
        8usize,
        concat!("Alignment of ", stringify!(elf64_shdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_link as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_info as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_addralign as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_addralign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_entsize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(elf64_shdr),
            "::",
            stringify!(sh_entsize)
        )
    );
}
pub type Elf64_Shdr = elf64_shdr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernel_param_ops {
    pub flags: c_types::c_uint,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            val: *const c_types::c_char,
            kp: *const kernel_param,
        ) -> c_types::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            buffer: *mut c_types::c_char,
            kp: *const kernel_param,
        ) -> c_types::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void)>,
}
#[test]
fn bindgen_test_layout_kernel_param_ops() {
    assert_eq!(
        ::core::mem::size_of::<kernel_param_ops>(),
        32usize,
        concat!("Size of: ", stringify!(kernel_param_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_param_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_param_ops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).set as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).get as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param_ops),
            "::",
            stringify!(free)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_param {
    pub name: *const c_types::c_char,
    pub mod_: *mut module,
    pub ops: *const kernel_param_ops,
    pub perm: u16,
    pub level: s8,
    pub flags: u8,
    pub __bindgen_anon_1: kernel_param__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_param__bindgen_ty_1 {
    pub arg: *mut c_types::c_void,
    pub str: *const kparam_string,
    pub arr: *const kparam_array,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_kernel_param__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<kernel_param__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(kernel_param__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_param__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_param__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).arg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param__bindgen_ty_1),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param__bindgen_ty_1),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param__bindgen_ty_1),
            "::",
            stringify!(arr)
        )
    );
}
impl Default for kernel_param__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_kernel_param() {
    assert_eq!(
        ::core::mem::size_of::<kernel_param>(),
        40usize,
        concat!("Size of: ", stringify!(kernel_param))
    );
    assert_eq!(
        ::core::mem::align_of::<kernel_param>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).mod_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).perm as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).level as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kernel_param>())).flags as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_param),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for kernel_param {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_string {
    pub maxlen: c_types::c_uint,
    pub string: *mut c_types::c_char,
}
#[test]
fn bindgen_test_layout_kparam_string() {
    assert_eq!(
        ::core::mem::size_of::<kparam_string>(),
        16usize,
        concat!("Size of: ", stringify!(kparam_string))
    );
    assert_eq!(
        ::core::mem::align_of::<kparam_string>(),
        8usize,
        concat!("Alignment of ", stringify!(kparam_string))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_string>())).maxlen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_string),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_string>())).string as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_string),
            "::",
            stringify!(string)
        )
    );
}
impl Default for kparam_string {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_array {
    pub max: c_types::c_uint,
    pub elemsize: c_types::c_uint,
    pub num: *mut c_types::c_uint,
    pub ops: *const kernel_param_ops,
    pub elem: *mut c_types::c_void,
}
#[test]
fn bindgen_test_layout_kparam_array() {
    assert_eq!(
        ::core::mem::size_of::<kparam_array>(),
        32usize,
        concat!("Size of: ", stringify!(kparam_array))
    );
    assert_eq!(
        ::core::mem::align_of::<kparam_array>(),
        8usize,
        concat!("Alignment of ", stringify!(kparam_array))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).max as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).elemsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(elemsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kparam_array>())).elem as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kparam_array),
            "::",
            stringify!(elem)
        )
    );
}
impl Default for kparam_array {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct latch_tree_node {
    pub node: [rb_node; 2usize],
}
#[test]
fn bindgen_test_layout_latch_tree_node() {
    assert_eq!(
        ::core::mem::size_of::<latch_tree_node>(),
        48usize,
        concat!("Size of: ", stringify!(latch_tree_node))
    );
    assert_eq!(
        ::core::mem::align_of::<latch_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(latch_tree_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<latch_tree_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(latch_tree_node),
            "::",
            stringify!(node)
        )
    );
}
impl Default for latch_tree_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct error_injection_entry {
    pub addr: c_types::c_ulong,
    pub etype: c_types::c_int,
}
#[test]
fn bindgen_test_layout_error_injection_entry() {
    assert_eq!(
        ::core::mem::size_of::<error_injection_entry>(),
        16usize,
        concat!("Size of: ", stringify!(error_injection_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<error_injection_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(error_injection_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<error_injection_entry>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(error_injection_entry),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<error_injection_entry>())).etype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(error_injection_entry),
            "::",
            stringify!(etype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mod_arch_specific {}
#[test]
fn bindgen_test_layout_mod_arch_specific() {
    assert_eq!(
        ::core::mem::size_of::<mod_arch_specific>(),
        0usize,
        concat!("Size of: ", stringify!(mod_arch_specific))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_arch_specific>(),
        1usize,
        concat!("Alignment of ", stringify!(mod_arch_specific))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_kobject {
    pub kobj: kobject,
    pub mod_: *mut module,
    pub drivers_dir: *mut kobject,
    pub mp: *mut module_param_attrs,
    pub kobj_completion: *mut completion,
}
#[test]
fn bindgen_test_layout_module_kobject() {
    assert_eq!(
        ::core::mem::size_of::<module_kobject>(),
        96usize,
        concat!("Size of: ", stringify!(module_kobject))
    );
    assert_eq!(
        ::core::mem::align_of::<module_kobject>(),
        8usize,
        concat!("Alignment of ", stringify!(module_kobject))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).kobj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(kobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).mod_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).drivers_dir as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(drivers_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).mp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_kobject>())).kobj_completion as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(module_kobject),
            "::",
            stringify!(kobj_completion)
        )
    );
}
impl Default for module_kobject {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *mut c_types::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *const c_types::c_char,
            count: usize,
        ) -> isize,
    >,
    pub setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut module, arg2: *const c_types::c_char),
    >,
    pub test: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> c_types::c_int>,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>,
}
#[test]
fn bindgen_test_layout_module_attribute() {
    assert_eq!(
        ::core::mem::size_of::<module_attribute>(),
        56usize,
        concat!("Size of: ", stringify!(module_attribute))
    );
    assert_eq!(
        ::core::mem::align_of::<module_attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(module_attribute))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).show as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).store as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(store)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).setup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).test as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(test)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_attribute>())).free as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(module_attribute),
            "::",
            stringify!(free)
        )
    );
}
impl Default for module_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const module_state_MODULE_STATE_LIVE: module_state = 0;
pub const module_state_MODULE_STATE_COMING: module_state = 1;
pub const module_state_MODULE_STATE_GOING: module_state = 2;
pub const module_state_MODULE_STATE_UNFORMED: module_state = 3;
pub type module_state = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_tree_node {
    pub mod_: *mut module,
    pub node: latch_tree_node,
}
#[test]
fn bindgen_test_layout_mod_tree_node() {
    assert_eq!(
        ::core::mem::size_of::<mod_tree_node>(),
        56usize,
        concat!("Size of: ", stringify!(mod_tree_node))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(mod_tree_node))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_tree_node>())).mod_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_tree_node),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_tree_node>())).node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_tree_node),
            "::",
            stringify!(node)
        )
    );
}
impl Default for mod_tree_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_layout {
    pub base: *mut c_types::c_void,
    pub size: c_types::c_uint,
    pub text_size: c_types::c_uint,
    pub ro_size: c_types::c_uint,
    pub ro_after_init_size: c_types::c_uint,
    pub mtn: mod_tree_node,
}
#[test]
fn bindgen_test_layout_module_layout() {
    assert_eq!(
        ::core::mem::size_of::<module_layout>(),
        80usize,
        concat!("Size of: ", stringify!(module_layout))
    );
    assert_eq!(
        ::core::mem::align_of::<module_layout>(),
        8usize,
        concat!("Alignment of ", stringify!(module_layout))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).text_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(text_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).ro_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(ro_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<module_layout>())).ro_after_init_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(ro_after_init_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_layout>())).mtn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(module_layout),
            "::",
            stringify!(mtn)
        )
    );
}
impl Default for module_layout {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_kallsyms {
    pub symtab: *mut Elf64_Sym,
    pub num_symtab: c_types::c_uint,
    pub strtab: *mut c_types::c_char,
}
#[test]
fn bindgen_test_layout_mod_kallsyms() {
    assert_eq!(
        ::core::mem::size_of::<mod_kallsyms>(),
        24usize,
        concat!("Size of: ", stringify!(mod_kallsyms))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_kallsyms>(),
        8usize,
        concat!("Alignment of ", stringify!(mod_kallsyms))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).symtab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_kallsyms),
            "::",
            stringify!(symtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).num_symtab as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_kallsyms),
            "::",
            stringify!(num_symtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).strtab as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_kallsyms),
            "::",
            stringify!(strtab)
        )
    );
}
impl Default for mod_kallsyms {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct klp_modinfo {
    pub hdr: Elf64_Ehdr,
    pub sechdrs: *mut Elf64_Shdr,
    pub secstrings: *mut c_types::c_char,
    pub symndx: c_types::c_uint,
}
#[test]
fn bindgen_test_layout_klp_modinfo() {
    assert_eq!(
        ::core::mem::size_of::<klp_modinfo>(),
        88usize,
        concat!("Size of: ", stringify!(klp_modinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<klp_modinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(klp_modinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).sechdrs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(sechdrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).secstrings as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(secstrings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<klp_modinfo>())).symndx as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(klp_modinfo),
            "::",
            stringify!(symndx)
        )
    );
}
impl Default for klp_modinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn get_random_bytes(buf: *mut c_types::c_void, nbytes: c_types::c_int);
}
extern "C" {
    pub fn wait_for_random_bytes() -> c_types::c_int;
}
extern "C" {
    pub fn rng_is_initialized() -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_cache {
    _unused: [u8; 0],
}
extern "C" {
    pub fn krealloc(arg1: *const c_types::c_void, arg2: usize, arg3: gfp_t)
        -> *mut c_types::c_void;
}
extern "C" {
    pub fn kfree(arg1: *const c_types::c_void);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct exception_table_entry {
    pub insn: c_types::c_int,
    pub fixup: c_types::c_int,
    pub handler: c_types::c_int,
}
#[test]
fn bindgen_test_layout_exception_table_entry() {
    assert_eq!(
        ::core::mem::size_of::<exception_table_entry>(),
        12usize,
        concat!("Size of: ", stringify!(exception_table_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<exception_table_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(exception_table_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception_table_entry>())).insn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(insn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception_table_entry>())).fixup as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(fixup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception_table_entry>())).handler as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(handler)
        )
    );
}
extern "C" {
    pub fn _copy_from_user(
        arg1: *mut c_types::c_void,
        arg2: *const c_types::c_void,
        arg3: c_types::c_ulong,
    ) -> c_types::c_ulong;
}
extern "C" {
    pub fn _copy_to_user(
        arg1: *mut c_types::c_void,
        arg2: *const c_types::c_void,
        arg3: c_types::c_ulong,
    ) -> c_types::c_ulong;
}
pub const BINDINGS_GFP_KERNEL: gfp_t = 6291648;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct c_msr {
    pub msr: c_types::c_uint,
    pub low: u32,
    pub high: u32,
}
#[test]
fn bindgen_test_layout_c_msr() {
    assert_eq!(
        ::core::mem::size_of::<c_msr>(),
        12usize,
        concat!("Size of: ", stringify!(c_msr))
    );
    assert_eq!(
        ::core::mem::align_of::<c_msr>(),
        4usize,
        concat!("Alignment of ", stringify!(c_msr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<c_msr>())).msr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(c_msr),
            "::",
            stringify!(msr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<c_msr>())).low as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(c_msr),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<c_msr>())).high as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(c_msr),
            "::",
            stringify!(high)
        )
    );
}
extern "C" {
    pub fn my_wrmsr(arg: *mut c_types::c_void);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_sect_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_notes_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct trace_event_call {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct trace_eval_map {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldt_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vm_operations_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rt_rq {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rt_mutex_waiter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct css_set {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct compat_robust_list_head {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct numa_group {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ftrace_ret_stack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uprobe {
    pub _address: u8,
}
#[doc = " @pgmap: Points to the hosting device page map."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pagemap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct userfaultfd_ctx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct anon_vma {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linux_binfmt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mmu_notifier_mm {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct hd_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gendisk {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xattr_handler {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mtd_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_param_attrs {
    pub _address: u8,
}
